<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Radu Matei - Developer Evangelist</title>
    <link>http://radu-matei.github.io/categories/signalr/index.xml</link>
    <description>Recent content on Radu Matei - Developer Evangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://radu-matei.github.io/categories/signalr/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Real-Time ASP .NET Core</title>
      <link>http://radu-matei.github.io/blog/real-time-aspnet-core/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/real-time-aspnet-core/</guid>
      <description>

&lt;h2 id=&#34;what-is-this&#34;&gt;What is this?&lt;/h2&gt;

&lt;p&gt;This is an ASP .NET Core middleware for providing real-time functionality to your applications. To its core, this is a WebSockets middleware for ASP .NET Core applications with TypeScript / JavaScript and .NET clients.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is an &lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;&lt;strong&gt;open-source library&lt;/strong&gt; available (for using and contributing) on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;why-wouldn-t-i-use-signalr-for-real-time&#34;&gt;Why wouldn&amp;rsquo;t I use SignalR for real-time?&lt;/h2&gt;

&lt;p&gt;Well, the reason is quite simple: SignalR for ASP .NET Core is still in its very incipient stages. A preview is expected mid-2017, while a release near the end of 2017, so most probably it will be available for ASP .NET Core 2.0.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/real-time-aspnet-core/timeline.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The preview and release information, as well as the photo above were taken from &lt;a href=&#34;https://vimeo.com/204078084&#34;&gt;this talk by Damian Edwards and David Fowler, the guys in charge of ASP .NET Core and SignalR&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Basically, this offers a way to provide real-time functionality to your application right now if you don&amp;rsquo;t want to wait until mid-2017 for a SignalR preview.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment, booting up a simple SignalR sample cannot be done under ASP .NET Core 1.1, the latest stable release of the framework.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;so-wait-is-this-related-to-signalr&#34;&gt;So wait. Is this related to SignalR?&lt;/h2&gt;

&lt;p&gt;Simple answer: &lt;strong&gt;NO. This is not an official release from Microsoft&lt;/strong&gt; and is not in any way related to the &lt;a href=&#34;https://github.com/aspnet/signalr&#34;&gt;SignalR project which is developed on GitHub in this repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, a lot of concepts were inspired from both the new and the old SignalR, so if you wrote SignalR in the past, a lot of the concepts will be familiar.&lt;/p&gt;

&lt;p&gt;Because the release of SignalR for ASP .NET Core was delayed for so long, I decided to write a very basic, stripped down (compared to the original SignalR) that only supports WebSockets (is based on &lt;code&gt;Microsoft.AspNetCore.WebSockets&lt;/code&gt;) with server support, TypeScript and C# clients.&lt;/p&gt;

&lt;p&gt;This started as a fun side project (and I am pretty sure it will stay this way once SignalR becomes ready for production).&lt;/p&gt;

&lt;h2 id=&#34;high-level-overview&#34;&gt;High-level overview&lt;/h2&gt;

&lt;p&gt;This library offers &lt;strong&gt;real-time functionality to ASP .NET Core applications&lt;/strong&gt;, using WebSockets. It also supports &lt;strong&gt;the client and the server calling each others&amp;rsquo; methods&lt;/strong&gt; (mainly like in the good old SignalR).&lt;/p&gt;

&lt;p&gt;In order to get real-time functionality in your application, you need to create a class (called &lt;code&gt;Handler&lt;/code&gt;, which inherits &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager/WebSocketHandler.cs&#34;&gt;&lt;code&gt;WebSocketHandler&lt;/code&gt;&lt;/a&gt;), that is very similar to the &lt;code&gt;Hub&lt;/code&gt; class in SignalR.&lt;/p&gt;

&lt;p&gt;Then, in this &lt;code&gt;Handler&lt;/code&gt; class you can create public methods that the (JavaScript and C#) clients can call, and can call client methods.&lt;/p&gt;

&lt;p&gt;Another approach is for MVC applications, where you create the &lt;code&gt;Handler&lt;/code&gt; class without any public methods, but as a proxy, and provide notifications to the clients from a controller (again, very much like in SignalR).&lt;/p&gt;

&lt;p&gt;The library uses a fire-and-forget approach both on the client and the server, meaning that it tells the server / client what method to call and that&amp;rsquo;s it, it doesn&amp;rsquo;t track the execution of that method.&lt;/p&gt;

&lt;p&gt;Next, we will use at how to add this library to an ASP .NET Core application.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-websocket-manager&#34;&gt;Getting started with websocket-manager&lt;/h2&gt;

&lt;p&gt;The easiest way to get started is to first clone / fork the project from GitHub.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;&lt;code&gt;git clone https://github.com/radu-matei/websocket-manager&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then, in the &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/master/samples&#34;&gt;&lt;code&gt;samples&lt;/code&gt;&lt;/a&gt; directory, make a new directory and create a new .NET Core application using the &lt;code&gt;dotnet new&lt;/code&gt; command. This will be our web application, and the reason we create it in the &lt;code&gt;samples&lt;/code&gt; folder is because we will need to add a reference to the &lt;code&gt;websocket-manager&lt;/code&gt; project (since the package is not yet on NuGet).&lt;/p&gt;

&lt;p&gt;Create a new .NET Core application using the &lt;code&gt;dotnet new&lt;/code&gt; command, then open the folder in VS Code. First of all, we need to update &lt;code&gt;project.json&lt;/code&gt; to reference a few NuGet packages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;:&amp;quot;1.1.0&amp;quot;&lt;/code&gt; (the Kestrel web server that makes this a web application)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;:&amp;quot;1.1.0&amp;quot;&lt;/code&gt; (package that allows us to server static files)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;Newtonsoft.Json&amp;quot;:&amp;quot;9.0.1&amp;quot;&lt;/code&gt; (we will not explicitly use Newtonsoft.Json, but this is a bug in the tooling where I also need to reference a package that I use in the library in the project using the library. This should not be necessary in future tooling releases.)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;WebSocketManager&amp;quot;: {
      &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
    }&lt;/code&gt; - this is the reference to the &lt;code&gt;websocket-manager&lt;/code&gt; project in the &lt;code&gt;src&lt;/code&gt; folder&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is how &lt;code&gt;project.json&lt;/code&gt; looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
  &amp;quot;buildOptions&amp;quot;: {
    &amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
    &amp;quot;emitEntryPoint&amp;quot;: true
  },
  &amp;quot;frameworks&amp;quot;: {
    &amp;quot;netcoreapp1.1&amp;quot;: {
      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.1.0&amp;quot;
        },
        &amp;quot;WebSocketManager&amp;quot;: {
          &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
        },
        &amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.1.0&amp;quot;,
        &amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;: &amp;quot;1.1.0&amp;quot;,
        &amp;quot;Newtonsoft.Json&amp;quot;: &amp;quot;9.0.1&amp;quot;
      },
      &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we need to update our &lt;code&gt;Program.cs&lt;/code&gt; to make this a web application, including our &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();

            host.Run();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far this looks just like all ASP .NET Core applications showcased on this blog before, just the bare minimum parts necessary.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s add a &lt;code&gt;Startup&lt;/code&gt; class.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;More on the &lt;code&gt;Startup&lt;/code&gt; class in this article.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;First of all, in the &lt;code&gt;ConfigureServices&lt;/code&gt; method we need to add the &lt;code&gt;WebSocketManager&lt;/code&gt; service that is used across &lt;code&gt;websocket-manager&lt;/code&gt;. This extension method adds &lt;code&gt;WebSocketConnectionManager&lt;/code&gt; to the &lt;code&gt;services&lt;/code&gt;, as well as all classes that inherit &lt;code&gt;WebSocketHandler&lt;/code&gt; (more on this later).&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;Configure&lt;/code&gt; method, we need to use WebSockets and Static Files. (The full &lt;code&gt;Startup&lt;/code&gt; class will be here soon).&lt;/p&gt;

&lt;h2 id=&#34;building-a-chat-application&#34;&gt;Building a chat application&lt;/h2&gt;

&lt;p&gt;The all present example when talking about SignalR was a chat application, and I couldn&amp;rsquo;t think of a better example, so we will build an ASP .NET Core chat application, with a webpage and a console application that logs every message.&lt;/p&gt;

&lt;p&gt;We will need to add a &lt;code&gt;Handler&lt;/code&gt; class that will allow the clients to connect to our application. This class needs to inherit the &lt;code&gt;WebSocketHandler&lt;/code&gt; class from the library.&lt;/p&gt;

&lt;p&gt;Since this uses the ASP .NET Core built-in dependency injection, this class will have a constructor that passes all relevant components (in this case &lt;code&gt;WebSocketManager&lt;/code&gt; - that we will not use directly).&lt;/p&gt;

&lt;p&gt;This class will handle clients connecting and disconecting, exposes public methods that clients directly call (invoke) and allows the invocation of client methods.&lt;/p&gt;

&lt;p&gt;The library uses a&lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager.Common/Message.cs&#34;&gt; &lt;code&gt;Message&lt;/code&gt; class&lt;/a&gt; to pass messages between the server and clients, which contains a &lt;code&gt;MessageType&lt;/code&gt; (most likely this will be a method invocation) and a &lt;code&gt;Data&lt;/code&gt; field which can be used to hold any JSON-serialized object (since it is a &lt;code&gt;string&lt;/code&gt; field). This is how we will pass log messages to the clients.&lt;/p&gt;

&lt;h2 id=&#34;connection-and-disconnection-events&#34;&gt;Connection and Disconnection events&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;        public override async Task OnConnected(WebSocket socket)
        {
            await base.OnConnected(socket);

            var socketId = WebSocketConnectionManager.GetId(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} is now connected&amp;quot;
            };

            await SendMessageToAllAsync(message);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all, we need to call &lt;code&gt;await base.OnConnected&lt;/code&gt; so that the framework registers the connection. Then, we can retrieve the &lt;code&gt;ConnectionId&lt;/code&gt; from the &lt;code&gt;WebSocketConnectionManager&lt;/code&gt; so that we can send all clients (by using &lt;code&gt;SendMessageToAllAsync&lt;/code&gt;) a log about who connected.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;SendMessageToAllAsync&lt;/code&gt; method will be mainly used to pass logs to the clients and will most likely be refactored to emphasise this aspect. But for now, you might want to send plain text messages to clients, rather than method invocations.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager/WebSocketHandler.cs#L70-L83&#34;&gt;&lt;code&gt;InvokeClientMethodAsync&lt;/code&gt; method&lt;/a&gt; also uses the &lt;code&gt;SendMessageAsync&lt;/code&gt; method, passing a serialized &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager.Common/InvocationDescriptor.cs&#34;&gt;&lt;code&gt;InvocationDescriptor&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;Data&lt;/code&gt; field.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In a similar manner we treat the disconnection event:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public override async Task OnDisconnected(WebSocket socket)
        {
            var socketId = WebSocketConnectionManager.GetId(socket);
            
            await base.OnDisconnected(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} disconnected&amp;quot;
            };
            await SendMessageToAllAsync(message);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The only notable difference here is that we retrieve the connection id before calling &lt;code&gt;base.OnDisconnected&lt;/code&gt;, since this method removes the connection id from the framework.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-server-methods-and-invoking-client-mehtods&#34;&gt;Creating server methods and invoking client mehtods&lt;/h2&gt;

&lt;p&gt;All &lt;code&gt;public&lt;/code&gt; methods in a &lt;code&gt;Handler&lt;/code&gt; class can be invoked by connected clients.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public async Task SendMessage(string socketId, string message)
{
    await InvokeClientMethodToAllAsync(&amp;quot;receiveMessage&amp;quot;, socketId, message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is how such a method would look like. When a client calls the &lt;code&gt;SendMessage&lt;/code&gt; method on the server, the server will tell all connected clients to invoke the &lt;code&gt;receiveMessage&lt;/code&gt; method, with &lt;code&gt;socketId&lt;/code&gt; and &lt;code&gt;message&lt;/code&gt; as parameters.&lt;/p&gt;

&lt;h2 id=&#34;the-full-chathandler-class&#34;&gt;The full &lt;code&gt;ChatHandler&lt;/code&gt; class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public class ChatHandler : WebSocketHandler
    {
        public ChatHandler(WebSocketConnectionManager webSocketConnectionManager) 
                                                    : base(webSocketConnectionManager)
        {
        }

        public override async Task OnConnected(WebSocket socket)
        {
            await base.OnConnected(socket);

            var socketId = WebSocketConnectionManager.GetId(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} is now connected&amp;quot;
            };

            await SendMessageToAllAsync(message);
        }
   
        public async Task SendMessage(string socketId, string message)
        {
            await InvokeClientMethodToAllAsync(&amp;quot;receiveMessage&amp;quot;, socketId, message);
        }

        public override async Task OnDisconnected(WebSocket socket)
        {
            var socketId = WebSocketConnectionManager.GetId(socket);
            
            await base.OnDisconnected(socket);

            var message = new Message()
            {
                MessageType = MessageType.Text,
                Data = $&amp;quot;{socketId} disconnected&amp;quot;
            };
            await SendMessageToAllAsync(message);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;plugging-the-handler-in-startup&#34;&gt;Plugging the handler in Startup&lt;/h2&gt;

&lt;p&gt;We created a &lt;code&gt;Handler&lt;/code&gt; class, but we need to register it in &lt;code&gt;Startup&lt;/code&gt; and map clients connecting to a specific path to this &lt;code&gt;ChatHandler&lt;/code&gt; class, since we can have multiple handlers in the same application.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;Configure&lt;/code&gt; method inside &lt;code&gt;Startup&lt;/code&gt;, we need to map all clients connecting to a path in our application (in this case &amp;ldquo;/chat&amp;rdquo;) to be handled by a &lt;code&gt;Handler&lt;/code&gt; class, in this case &lt;code&gt;ChatHandler&lt;/code&gt; (given by the service provider).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.MapWebSocketManager(&amp;quot;/chat&amp;quot;, serviceProvider.GetService&amp;lt;ChatHandler&amp;gt;());&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the full &lt;code&gt;Configure&lt;/code&gt; method in &lt;code&gt;Startup&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public void Configure(IApplicationBuilder app, IServiceProvider serviceProvider)
        {
            app.UseWebSockets();
            app.MapWebSocketManager(&amp;quot;/chat&amp;quot;, serviceProvider.GetService&amp;lt;ChatHandler&amp;gt;());

            app.UseStaticFiles();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much it on the server side. Next, we will create web and .NET clients.&lt;/p&gt;

&lt;h2 id=&#34;creating-the-web-client&#34;&gt;Creating the web client&lt;/h2&gt;

&lt;p&gt;So far we created the server part of our chat application. Now let&amp;rsquo;s look at creating the JavaScript part for connecting to our application.&lt;/p&gt;

&lt;p&gt;First, we need to create a &lt;code&gt;wwwroot&lt;/code&gt; folder in the root of our web application, and in there create a new HTML file.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can take a look at the &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/master/src/WebSocketManager.Client.TS/src/Connection.ts&#34;&gt;TypeScript client on GitHub.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In an HTML page we will use the JavaScript transpiled version of the TypeScript client. To use, simply &lt;a href=&#34;https://rawgit.com/radu-matei/websocket-manager/master/src/WebSocketManager.Client.TS/dist/WebSocketManager.js&#34;&gt;include this script in your page that was generated by WebPack.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After including the &lt;code&gt;WebSocketManager&lt;/code&gt; script in your page, in order to create a new connection write:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var connection = new WebSocketManager.Connection(&amp;quot;ws://localhost:5000/chat&amp;quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, create client methods that the server can invoke:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            connection.clientMethods[&amp;quot;receiveMessage&amp;quot;] = (socketId, message) =&amp;gt; {
                var messageText = socketId + &amp;quot; said: &amp;quot; + message;
               
                console.log(messageText);
                // do something with the message
            };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, simply start the connection:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connection.start();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;And this is pretty much it. You can configure logging and have custom functionality for connection and disconnection events, but all those are optional.&lt;/p&gt;

&lt;p&gt;The following page has a text input area, a button and a message list - a very basic chat page.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note the optional connection and disconnection methods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Test Page&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;This should be mapped to &amp;quot;/chat&amp;quot;&amp;lt;/h1&amp;gt;
    &amp;lt;input type=text id=&amp;quot;textInput&amp;quot; placeholder=&amp;quot;Enter your text&amp;quot; /&amp;gt;
    &amp;lt;button id=&amp;quot;sendButton&amp;quot;&amp;gt;Send&amp;lt;/button&amp;gt;

    &amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;


    &amp;lt;script data-main=&amp;quot;scripts/main&amp;quot; src=&amp;quot;https://rawgit.com/radu-matei/websocket-manager/master/src/WebSocketManager.Client.TS/dist/WebSocketManager.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

    &amp;lt;script language=&amp;quot;javascript&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;
          
            var connection = new WebSocketManager.Connection(&amp;quot;ws://localhost:5000/chat&amp;quot;);
            connection.enableLogging = true;

            connection.connectionMethods.onConnected = () =&amp;gt; {
                //optional
                console.log(&amp;quot;You are now connected! Connection ID: &amp;quot; + connection.connectionId);
            }

            connection.connectionMethods.onDisconnected = () =&amp;gt; {
                //optional
                console.log(&amp;quot;Disconnected!&amp;quot;);
            }

            connection.clientMethods[&amp;quot;receiveMessage&amp;quot;] = (socketId, message) =&amp;gt; {
                var messageText = socketId + &amp;quot; said: &amp;quot; + message;
               
                console.log(messageText);
                appendItem(list, messageText);
            };

            connection.start();

            var list = document.getElementById(&amp;quot;messages&amp;quot;);
            var button = document.getElementById(&amp;quot;sendButton&amp;quot;); 
            button.addEventListener(&amp;quot;click&amp;quot;, function() {
            
                var input = document.getElementById(&amp;quot;textInput&amp;quot;);
                connection.invoke(&amp;quot;SendMessage&amp;quot;, connection.connectionId, input.value);
            
                input.value = &amp;quot;&amp;quot;;
            });
            
            function appendItem(list, message) {
                var item = document.createElement(&amp;quot;li&amp;quot;);
                item.appendChild(document.createTextNode(message));
                list.appendChild(item);
             }
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much the entire chat application. You can find it on GitHub, as &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/master/samples/ChatApplication&#34;&gt;the &lt;code&gt;ChatApplication&lt;/code&gt; sample in the repo.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-does-this-really-work&#34;&gt;So does this really work?&lt;/h2&gt;

&lt;p&gt;Simply start the ASP .NET Core web application and navigate to &lt;code&gt;http://localhost:5000/client.html&lt;/code&gt; (if you run directly the sample in the GitHub repository).&lt;/p&gt;

&lt;p&gt;Then, start another tab with the same page and check it out:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/real-time-aspnet-core/web-chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-net-client&#34;&gt;The .NET Client&lt;/h2&gt;

&lt;p&gt;As I said earlier, there is also a C# client. Simply start a new .NET Core console application, reference the &lt;code&gt;WebsocketManager.Client&lt;/code&gt; project from the repository and start a new connection. First, let&amp;rsquo;s look at &lt;code&gt;project.json&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/master/samples/EchoConsoleClient&#34;&gt;The C# client is available on GitHub, under the &lt;code&gt;samples&lt;/code&gt; folder.&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0-*&amp;quot;,
  &amp;quot;buildOptions&amp;quot;: {
    &amp;quot;debugType&amp;quot;: &amp;quot;portable&amp;quot;,
    &amp;quot;emitEntryPoint&amp;quot;: true
  },
  &amp;quot;dependencies&amp;quot;: {},
  &amp;quot;frameworks&amp;quot;: {
    &amp;quot;netcoreapp1.1&amp;quot;: {
      &amp;quot;dependencies&amp;quot;: {
        &amp;quot;Microsoft.NETCore.App&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;platform&amp;quot;,
          &amp;quot;version&amp;quot;: &amp;quot;1.1.0&amp;quot;
        },
        &amp;quot;WebSocketManager.Client&amp;quot;: {
          &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
        },
        &amp;quot;WebSocketManager.Common&amp;quot;: {
          &amp;quot;target&amp;quot;: &amp;quot;project&amp;quot;
        }
      },
      &amp;quot;imports&amp;quot;: &amp;quot;dnxcore50&amp;quot;
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that I also had to include the &lt;code&gt;Common&lt;/code&gt; project - the same bug that made me include &lt;code&gt;Newtonsoft.Json&lt;/code&gt; in the web application - hopefully with the new tooling of .NET Core this will not be necessary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, the program itself is rather simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Program 
{
    private static Connection _connection;
    public static void Main(string[] args)
    {
        StartConnectionAsync();

        _connection.On(&amp;quot;receiveMessage&amp;quot;, (arguments) =&amp;gt; 
        {
            Console.WriteLine($&amp;quot;{arguments[0]} said: {arguments[1]}&amp;quot;);
        });

        Console.ReadLine();
        StopConnectionAsync();
    }

    public static async Task StartConnectionAsync()
    {
        _connection = new Connection();
        await _connection.StartConnectionAsync(&amp;quot;ws://localhost:5000/chat&amp;quot;);
    }

    public static async Task StopConnectionAsync()
    {
        await _connection.StopConnectionAsync();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While keeping the web application running, start this console application as well and the behavior should be similar to:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/real-time-aspnet-core/console-chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;integrating-this-in-an-mvc-application&#34;&gt;Integrating this in an MVC application&lt;/h2&gt;

&lt;p&gt;Most applications are not chat applications. And in most ASP .NET Core applications MVC is used. This library can also be integrated with MVC, so you can have most of the traffic going through MVC and only the notifications going through WebSocketManager.&lt;/p&gt;

&lt;p&gt;Since the client will not invoke &lt;code&gt;Handler&lt;/code&gt; methods directly, the &lt;code&gt;Handler&lt;/code&gt; class only contains the constructor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class NotificationsMessageHandler : WebSocketHandler
    {
        public NotificationsMessageHandler(WebSocketConnectionManage webSocketConnectionManager) 
                        : base(webSocketConnectionManager)
        {
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the MVC Controller simply have a property of the &lt;code&gt;Handler&lt;/code&gt; type and use it to invoke client methods inside controller methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class MessagesController : Controller
    {
        private NotificationsMessageHandler _notificationsMessageHandler { get; set; }

        public MessagesController(NotificationsMessageHandler notificationsMessageHandler)
        {
            _notificationsMessageHandler = notificationsMessageHandler;
        }

        [HttpGet]
        public async Task SendMessage([FromQueryAttribute]string message)
        {
           await _notificationsMessageHandler.InvokeClientMethodToAllAsync(&amp;quot;receiveMessage&amp;quot;, message);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is pretty much it!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/real-time-aspnet-core/mvc.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As I stated many times so far, this started as a fun side project and will probably remain so. The new SignalR will bring awesome new features and I will surely enjoy working with it.&lt;/p&gt;

&lt;p&gt;But until it is ready to play with, this brings an alternative to bringing real-time functionality to your ASP .NET Core applications.&lt;/p&gt;

&lt;h2 id=&#34;contributing-to-this-project-https-github-com-radu-matei-websocket-manager&#34;&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;Contributing to this project&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;Contributions of any type are welcomed! Please visit the GitHub repository and create issues and pull requests.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;feedback-wanted&#34;&gt;Feedback wanted&lt;/h2&gt;

&lt;p&gt;If you stumbled upon this article, please take a moment and provide some feedback both on the library itself and on the way the article is written. Any feedback is immensely appreciated, as well as questions and observations.&lt;/p&gt;

&lt;h2 id=&#34;thanks-for-reading&#34;&gt;Thanks for reading :)&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Creating a WebSockets middleware for ASP .NET Core</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-websockets-middleware/</link>
      <pubDate>Fri, 30 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-websockets-middleware/</guid>
      <description>

&lt;h2 id=&#34;update-february-2017&#34;&gt;UPDATE - February 2017&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://radu-matei.github.ioblog/real-time-aspnet-core/&#34;&gt;This article describes the latest development of websocket-manager and how to use it in your application&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While the general aspects provided in this article about creating a websockets middleware for Asp .Net Core are still valid, the specific information about the websocket-manager project have changed, since I updated a lot of parts.&lt;/p&gt;

&lt;p&gt;The version of the project described in this article can still be found in the &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article&#34;&gt;&lt;code&gt;blog-article&lt;/code&gt;&lt;/a&gt; branch on GitHub.&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection.&lt;/p&gt;

&lt;p&gt;WebSocket is designed to be implemented in web browsers and web servers, but it can be used by any client or server application. The WebSocket Protocol is an independent TCP-based protocol.&lt;/p&gt;

&lt;p&gt;More from &lt;a href=&#34;https://en.wikipedia.org/wiki/WebSocket&#34;&gt;Wikipedia on WebSockets&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the traditional paradigm of the web, the client was the one responsible for initiating the communication with a server, and the server could not send data back unless it had been previously requested by the client.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/request.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With WebSockets, you can send data between the server and the client over a single TCP connection, and usually WebSockets are used to provide real-time functionality to modern applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/sockets.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.pubnub.com/wp-content/uploads/2014/09/WebSockets-Diagram.png&#34;&gt;Image from pubnub.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;what-is-this-article-about&#34;&gt;What is this article about?&lt;/h2&gt;

&lt;p&gt;This article is about WebSockets in ASP.NET Core. We will learn how to use them in a simple web application by building a middleware that manages WebSocket connections and sends messages to multiple clients.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can find a &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article&#34;&gt;repository containing the source code of this article on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I created a branch for this article since I will most likely update things in the future. For the latest version, check the &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;dev&lt;/code&gt; branches.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For the past few months I&amp;rsquo;ve been meaning to write a middleware for ASP .NET Core but never quite got the right idea for it. &lt;a href=&#34;https://radu-matei.github.io/categories/signalr/&#34;&gt;I have also been playing with the old SignalR on ASP .NET Core&lt;/a&gt; (which by the way, got discontinued and &lt;a href=&#34;https://github.com/aspnet/signalr&#34;&gt;work is being done in a new repo here&lt;/a&gt;), so I was aware of the WebSockets package but didn&amp;rsquo;t have the chance to play with it.&lt;/p&gt;

&lt;p&gt;Then I decided that for a side project I would need some real-time functionality, and since I was on ASP .NET Core and SignalR was not yet ready to be played with, I decided to write a simple middleware to manage WebSocket connections.&lt;/p&gt;

&lt;p&gt;Now, the middleware we are about to build is at most useful if you know the clients will support WebSocket connectivity (unlike a Windows 7 PC for example) and is only intended as an fun side project, in no case having production in mind.&lt;/p&gt;

&lt;p&gt;It was also built on the experience I had using SignalR for a while now, so you if find yourself wondering: &lt;em&gt;Didn&amp;rsquo;t I see something similar with SignalR?&lt;/em&gt;, the answer is most likely &lt;em&gt;Yes, you did!&lt;/em&gt;. This middleware resembles SignalR in sending real-time data, but only has WebSockets as transport, doesn&amp;rsquo;t handle reconnection events and currently does not support the server and the clients calling each others&amp;rsquo; methods.&lt;/p&gt;

&lt;p&gt;That being said, let&amp;rsquo;s start exploring how to use WebSockets in ASP .NET Core.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-websockets-in-asp-net-core&#34;&gt;Getting started with WebSockets in ASP .NET Core&lt;/h2&gt;

&lt;p&gt;There is no point in writing a &amp;ldquo;WebSockets 101&amp;rdquo; article since there are a few that explain very well what you need in order to get started and I will list the articles I used when getting started:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/aspnet/websockets&#34;&gt;the WebSockets repository on GitHub contains all source code for this package&lt;/a&gt; and it really helps you to understand how everything works&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://zbrad.github.io/tools/wscore/&#34;&gt;article from Brad Merrill that also contains GitHub repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://dotnetthoughts.net/using-websockets-in-aspnet-core/&#34;&gt;article by Anuraj P from dotnetthoughts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basically, you need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;add a reference to &lt;code&gt;Microsoft.AspNetCore.WebSockets&lt;/code&gt; in &lt;code&gt;project.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add &lt;code&gt;app.UseWebSockets()&lt;/code&gt; in the &lt;code&gt;Configure&lt;/code&gt; method inside the &lt;code&gt;Startup&lt;/code&gt; class&lt;/li&gt;
&lt;li&gt;create a response pipeline that handles WebSockets requests&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Both articles referenced above contain step-by-step examples on how to get this working&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/aspnet/WebSockets/tree/dev/samples/EchoApp&#34;&gt;In the official WebSockets repository on GitHub you can find a sample of a full application that echoes all messages received&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;asp-net-core-middleware&#34;&gt;ASP .NET Core Middleware&lt;/h2&gt;

&lt;p&gt;First of all, it is important to understand what middleware is and how the new request pipeline works in ASP .NET Core, and there is a &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware&#34;&gt;great article on that from the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Middleware are software components that are assembled into an application pipeline to handle requests and responses. Each component chooses whether to pass the request on to the next component in the pipeline, and can perform certain actions before and after the next component is invoked in the pipeline. Request delegates are used to build the request pipeline. The request delegates handle each HTTP request.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/request-pipeline.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/_static/request-delegate-pipeline.png&#34;&gt;Image from the Official ASP .NET Core Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The new pipeline consists of a series of &lt;code&gt;RequestDelegate&lt;/code&gt; objects being called one after the next, and each component can perform operations before and after the next delegate, or can short-cirtuit the pipeline, handle the request itself and not pass the context further.&lt;/p&gt;

&lt;p&gt;Before writing the middleware itself, we need a few classes that deal with connections and handling messages.&lt;/p&gt;

&lt;h2 id=&#34;writing-a-websocket-connection-manager&#34;&gt;Writing a WebSocket Connection Manager&lt;/h2&gt;

&lt;p&gt;The first thing we notice when using the WebSocket package is that everything is low-level: we deal with individual connections, buffers and cancellation tokens. There is no built-in way of storing sockets, nor are they identified in any way. So we will build a class that keeps all active sockets in a thread-safe collection and assigns each a unique ID, while also maintaning the collection (getting, adding and removing sockets).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Collections.Concurrent;
using System.Linq;
using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;

namespace WebSocketManager
{
    public class WebSocketConnectionManager
    {
        private ConcurrentDictionary&amp;lt;string, WebSocket&amp;gt; _sockets = new ConcurrentDictionary&amp;lt;string, WebSocket&amp;gt;();

        public WebSocket GetSocketById(string id)
        {
            return _sockets.FirstOrDefault(p =&amp;gt; p.Key == id).Value;
        }

        public ConcurrentDictionary&amp;lt;string, WebSocket&amp;gt; GetAll()
        {
            return _sockets;
        }

        public string GetId(WebSocket socket)
        {
            return _sockets.FirstOrDefault(p =&amp;gt; p.Value == socket).Key;
        }
        public void AddSocket(WebSocket socket)
        {
            _sockets.TryAdd(CreateConnectionId(), socket);
        }

        public async Task RemoveSocket(string id)
        {
            WebSocket socket;
            _sockets.TryRemove(id, out socket);

            await socket.CloseAsync(closeStatus: WebSocketCloseStatus.NormalClosure, 
                                    statusDescription: &amp;quot;Closed by the WebSocketManager&amp;quot;, 
                                    cancellationToken: CancellationToken.None);
        }

        private string CreateConnectionId()
        {
            return Guid.NewGuid().ToString();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As I said, it holds the sockets and the socket IDs in a concurrent dictionary and deals with getting, adding and removing sockets.&lt;/p&gt;

&lt;h2 id=&#34;writing-a-websocket-handler&#34;&gt;Writing a WebSocket Handler&lt;/h2&gt;

&lt;p&gt;Now that we have a way of keeping track of the connected clients, we want a class that handles connection and disconnection events and manages sending and receiving messages from the socket. Let&amp;rsquo;s see how a class like this might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace WebSocketManager
{
    public abstract class WebSocketHandler
    {
        protected WebSocketConnectionManager WebSocketConnectionManager { get; set; }

        public WebSocketHandler(WebSocketConnectionManager webSocketConnectionManager)
        {
            WebSocketConnectionManager = webSocketConnectionManager;
        }

        public virtual async Task OnConnected(WebSocket socket)
        {
            WebSocketConnectionManager.AddSocket(socket);
        }

        public virtual async Task OnDisconnected(WebSocket socket)
        {
            await WebSocketConnectionManager.RemoveSocket(WebSocketConnectionManager.GetId(socket));
        }

        public async Task SendMessageAsync(WebSocket socket, string message)
        {
            if(socket.State != WebSocketState.Open)
                return;

            await socket.SendAsync(buffer: new ArraySegment&amp;lt;byte&amp;gt;(array: Encoding.ASCII.GetBytes(message),
                                                                  offset: 0, 
                                                                  count: message.Length),
                                   messageType: WebSocketMessageType.Text,
                                   endOfMessage: true,
                                   cancellationToken: CancellationToken.None);          
        }

        public async Task SendMessageAsync(string socketId, string message)
        {
            await SendMessageAsync(WebSocketConnectionManager.GetSocketById(socketId), message);
        }

        public async Task SendMessageToAllAsync(string message)
        {
            foreach(var pair in WebSocketConnectionManager.GetAll())
            {
                if(pair.Value.State == WebSocketState.Open)
                    await SendMessageAsync(pair.Value, message);
            }
        }

        public abstract Task ReceiveAsync(WebSocket socket, WebSocketReceiveResult result, byte[] buffer);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing to notice is that the class is &lt;code&gt;abstract&lt;/code&gt;. This means &lt;strong&gt;you need to inherit it&lt;/strong&gt; and provide actual implementation for the &lt;code&gt;ReceiveAsync&lt;/code&gt; method, as well as you can &lt;code&gt;override&lt;/code&gt; the methods marked as &lt;code&gt;virtual&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s the &lt;code&gt;OnConnected&lt;/code&gt; and &lt;code&gt;OnDisconnected&lt;/code&gt; methods that are executed whenever a new socket connects or an existing one sends a &lt;code&gt;Close&lt;/code&gt; message.&lt;/p&gt;

&lt;p&gt;These methods are &lt;code&gt;virtual&lt;/code&gt;, meaning that you can provide your own functionality for connecting and disconnecting events.&lt;/p&gt;

&lt;p&gt;There is also the &lt;code&gt;SendMessageAsync&lt;/code&gt; which sends a message to a specific &lt;code&gt;socketId&lt;/code&gt; and &lt;code&gt;SendMessageToAllAsync&lt;/code&gt;, which sends a message to all connected clients.&lt;/p&gt;

&lt;h2 id=&#34;the-middleware-itself&#34;&gt;The middleware itself&lt;/h2&gt;

&lt;p&gt;So far we built classes that help maintaning a record of connected sockets and handle sending and receiving messages to and from those sockets. Now it&amp;rsquo;s time to build the actual middleware:&lt;/p&gt;

&lt;p&gt;As any middleware, it needs to receive a &lt;code&gt;RequestDelegate&lt;/code&gt; for the &lt;code&gt;next&lt;/code&gt; component in the pipeline, while executing operations on the &lt;code&gt;HttpContext&lt;/code&gt; before and after invoking the next component, and it needs an &lt;code&gt;async Task Invoke&lt;/code&gt; method. It doesn&amp;rsquo;t have to inherit or implement anything, just to have the &lt;code&gt;Invoke&lt;/code&gt; method.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You will notice in this version of the middleware that the invocation of the &lt;code&gt;next&lt;/code&gt; component is commented out. This is because an exception thrown by Kestrel when this is the last middleware registered in the pipeline. I will investigate this and update the class as necessary.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;using System.Net.WebSockets;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;

namespace WebSocketManager
{
    public class WebSocketManagerMiddleware
    {
        private readonly RequestDelegate _next;
        private WebSocketHandler _webSocketHandler { get; set; }

        public WebSocketManagerMiddleware(RequestDelegate next, 
                                          WebSocketHandler webSocketHandler)
        {
            _next = next;
            _webSocketHandler = webSocketHandler;
        }

        public async Task Invoke(HttpContext context)
        {
            if(!context.WebSockets.IsWebSocketRequest)
                return;
            
            var socket = await context.WebSockets.AcceptWebSocketAsync();
            await _webSocketHandler.OnConnected(socket);
            
            await Receive(socket, async(result, buffer) =&amp;gt;
            {
                if(result.MessageType == WebSocketMessageType.Text)
                {
                    await _webSocketHandler.ReceiveAsync(socket, result, buffer);
                    return;
                }

                else if(result.MessageType == WebSocketMessageType.Close)
                {
                    await _webSocketHandler.OnDisconnected(socket);
                    return;
                }

            });
            
            //TODO - investigate the Kestrel exception thrown when this is the last middleware
            //await _next.Invoke(context);
        }

        private async Task Receive(WebSocket socket, Action&amp;lt;WebSocketReceiveResult, byte[]&amp;gt; handleMessage)
        {
            var buffer = new byte[1024 * 4];

            while(socket.State == WebSocketState.Open)
            {
                var result = await socket.ReceiveAsync(buffer: new ArraySegment&amp;lt;byte&amp;gt;(buffer),
                                                       cancellationToken: CancellationToken.None);

                handleMessage(result, buffer);                
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The middleware is passed an implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt; and a &lt;code&gt;RequestDelegate&lt;/code&gt;. If the request is not a WebSocket request, it just exits the middleware.&lt;/p&gt;

&lt;p&gt;If it is a WebSockets request, then it accepts the connection and passes the socket to the &lt;code&gt;OnConnected&lt;/code&gt; method from the &lt;code&gt;WebSocketHandler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then, while the socket is in the &lt;code&gt;Open&lt;/code&gt; state, it awaits for the receival of new data. When it receives the data, it decides wether to pass the context to the &lt;code&gt;ReceiveAsync&lt;/code&gt; method of &lt;code&gt;WebSocketHandler&lt;/code&gt; (notice why you need to pass an actual implementation of the abstract &lt;code&gt;WebSocketHandler&lt;/code&gt; class) or to the &lt;code&gt;OnDisconnected&lt;/code&gt; method (if the message type is &lt;code&gt;Close&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;And basically this is the middleware. There is also a static class for adding extension methods that we will cover briefly.&lt;/p&gt;

&lt;h2 id=&#34;the-extension-methods-for-adding-the-middleware&#34;&gt;The extension methods for adding the middleware&lt;/h2&gt;

&lt;p&gt;Most likely in modern applications you want to send notifications and messages only to clients connected to a specific part of the application (think SignalR Hubs).&lt;/p&gt;

&lt;p&gt;With this middleware, you can map different paths of your application with specific implementations of &lt;code&gt;WebSocketHandler&lt;/code&gt;, so you would get completely isolated environments (and different instances of &lt;code&gt;WebSocketConnectionManager&lt;/code&gt;, but more on this later).&lt;/p&gt;

&lt;p&gt;So mapping the middeware is done using the following extension method on &lt;code&gt;IApplicationBuilder&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static IApplicationBuilder MapWebSocketManager(this IApplicationBuilder app, 
                                                              PathString path,
                                                              WebSocketHandler handler)
        {
            return app.Map(path, (_app) =&amp;gt; _app.UseMiddleware&amp;lt;WebSocketManagerMiddleware&amp;gt;(handler));
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It receives a path and it maps that path using with the &lt;code&gt;WebSocketManagerMiddleware&lt;/code&gt; which is passed the specific implementation of &lt;code&gt;WebSockethandler&lt;/code&gt; you provided as argument for the &lt;code&gt;MapWebSocketManager&lt;/code&gt; extension method.&lt;/p&gt;

&lt;p&gt;You also need to add some services in order to use them, and this is done in another extension method on &lt;code&gt;IServiceCollection&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static IServiceCollection AddWebSocketManager(this IServiceCollection services)
        {
            services.AddTransient&amp;lt;WebSocketConnectionManager&amp;gt;();

            foreach(var type in Assembly.GetEntryAssembly().ExportedTypes)
            {
                if(type.GetTypeInfo().BaseType == typeof(WebSocketHandler))
                {
                    services.AddSingleton(type);
                }
            }

            return services;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides from adding the &lt;code&gt;WebSocketConnectionManager&lt;/code&gt; service, it also searches the executing assemly for types that inherit &lt;code&gt;WebSocketHandler&lt;/code&gt; and it registers them as singleton (so that every request gets the same instance of the message handler) using reflection.&lt;/p&gt;

&lt;p&gt;And this is pretty much the middleware. Now we will take a look at how we would use it in ASP .NET Core applications, and just like in the case of SignalR, there are two scenarios for usage:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;one where the client actually sends WebSockets requests&lt;/li&gt;
&lt;li&gt;one where the client does some MVC stuff and the other clients get notified&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment the samples only handle string as messages, but I will handle JSON messages being sent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;scenario-1-client-sending-messages-through-websockets&#34;&gt;Scenario 1 - Client Sending messages through WebSockets&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article/samples/ChatApplication&#34;&gt;find the working application and the source code on GitHub here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Using the middleware we just created we will build a chat application (I know, everybody demoes chat applications when playing around with WebSockets).&lt;/p&gt;

&lt;p&gt;Besides being a public chat application, it will also be able to map very basic &lt;em&gt;chat rooms&lt;/em&gt; by creating (in this example) two message handlers and isolating clients from one page from the others.&lt;/p&gt;

&lt;p&gt;As I said earlier, in order to configure the newly created pipeline, we need to call the extension method &lt;code&gt;MapWebSocketManager&lt;/code&gt; in the following way:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;app.MapWebSocketManager(&amp;quot;/path&amp;quot;, instanceOfWebSocketHandler);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see a real project&amp;rsquo;s &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

using WebSocketManager;

namespace ChatApplication
{
    public class Startup
    {
        public void Configure(IApplicationBuilder app, IServiceProvider serviceProvider)
        {
            app.UseWebSockets();

            app.MapWebSocketManager(&amp;quot;/ws&amp;quot;, serviceProvider.GetService&amp;lt;ChatMessageHandler&amp;gt;());
            app.MapWebSocketManager(&amp;quot;/test&amp;quot;, serviceProvider.GetService&amp;lt;TestMessageHandler&amp;gt;());

            app.UseStaticFiles();
        }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddWebSocketManager();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we need to &lt;code&gt;UseWebSockets()&lt;/code&gt; (working on putting this inside the extension methods so you don&amp;rsquo;t call it manually), then map the paths you want to be handled by the middleware.&lt;/p&gt;

&lt;p&gt;We said that we need to pass the &lt;code&gt;MapWebSocketManager&lt;/code&gt; method an implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt;. Remember that in the extension method we registered all types that inherited &lt;code&gt;WebSocketHandler&lt;/code&gt; as singletons in the framework. So at this moment we can use the &lt;code&gt;IServiceProvider&lt;/code&gt; to give us instances of those classes.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at an actual implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt;, &lt;code&gt;ChatMessageHandler&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Net.WebSockets;
using System.Text;
using System.Threading.Tasks;
using WebSocketManager;

namespace ChatApplication
{
    public class ChatMessageHandler : WebSocketHandler
    {
        public ChatMessageHandler(WebSocketConnectionManager webSocketConnectionManager) : base(webSocketConnectionManager)
        {
        }

        public override async Task OnConnected(WebSocket socket)
        {
            await base.OnConnected(socket);

            var socketId = WebSocketConnectionManager.GetId(socket);
            await SendMessageToAllAsync($&amp;quot;{socketId} is now connected&amp;quot;);
        }

        public override async Task ReceiveAsync(WebSocket socket, WebSocketReceiveResult result, byte[] buffer)
        {
            var socketId = WebSocketConnectionManager.GetId(socket);
            var message = $&amp;quot;{socketId} said: {Encoding.UTF8.GetString(buffer, 0, result.Count)}&amp;quot;;

            await SendMessageToAllAsync(message);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It overrides the &lt;code&gt;OnConnected&lt;/code&gt; method to send a message to everybody broadcasting that a new client connected and it implements the &lt;code&gt;ReceiveAsync&lt;/code&gt; method (by just broadcasting the method to all clients).&lt;/p&gt;

&lt;p&gt;Basically, &lt;code&gt;TestMessageHandler&lt;/code&gt; does mostly the same things, but in a real world application you would have different functionality.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s add a web client that connects through WebSockets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Real-Time Notifications&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;This should be mapped to &amp;quot;/ws&amp;quot;&amp;lt;/h1&amp;gt;
    &amp;lt;input type=text id=&amp;quot;textInput&amp;quot; placeholder=&amp;quot;Enter your text&amp;quot;/&amp;gt;
    &amp;lt;button id=&amp;quot;sendButton&amp;quot;&amp;gt;Send&amp;lt;/button&amp;gt;

    &amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;

        &amp;lt;script language=&amp;quot;javascript&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        var uri = &amp;quot;ws://&amp;quot; + window.location.host + &amp;quot;/ws&amp;quot;;
        function connect() {
            socket = new WebSocket(uri);
            socket.onopen = function(event) {
                console.log(&amp;quot;opened connection to &amp;quot; + uri);
            };
            socket.onclose = function(event) {
                console.log(&amp;quot;closed connection from &amp;quot; + uri);
            };
            socket.onmessage = function(event) {
                appendItem(list, event.data);
                console.log(event.data);
            };
            socket.onerror = function(event) {
                console.log(&amp;quot;error: &amp;quot; + event.data);
            };
        }
        connect();
        var list = document.getElementById(&amp;quot;messages&amp;quot;);
        var button = document.getElementById(&amp;quot;sendButton&amp;quot;); 
        button.addEventListener(&amp;quot;click&amp;quot;, function() {
            
            var input = document.getElementById(&amp;quot;textInput&amp;quot;);
            sendMessage(input.value);
            
            input.value = &amp;quot;&amp;quot;;
        });
        function sendMessage(message) { 
            console.log(&amp;quot;Sending: &amp;quot; + message);
            socket.send(message);
        }
        function appendItem(list, message) {
            var item = document.createElement(&amp;quot;li&amp;quot;);
            item.appendChild(document.createTextNode(message));
            list.appendChild(item);
        }    
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a very simple web page that has an input form and a button. It connects to the server on the &amp;ldquo;/ws&amp;rdquo; path, so all requests will be mapped to &lt;code&gt;ChatMessageHandler&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that messages are passed real-time to all connected clients. Let&amp;rsquo;s add another page that connects to a different path - &amp;ldquo;/test&amp;rdquo; and pass another handler, &lt;code&gt;TestMessageHandler&lt;/code&gt; and another client, &lt;code&gt;test.html&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Remember that you can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article/samples/ChatApplication&#34;&gt;find the full working sample on GitHub here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s see what happens now:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/separate-chat.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can clearly see that clients receive messages based on the page they are connected to.&lt;/p&gt;

&lt;p&gt;In this case, clients would send data directly through a websocket and the socket events would get handled directly in the specific implementation of &lt;code&gt;WebSocketHandler&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;scenario-2-receiving-real-time-notifications-from-a-controller&#34;&gt;Scenario 2 - Receiving real-time notifications from a controller&lt;/h2&gt;

&lt;p&gt;This time we will build an MVC application and have client send data through the MVC pipeline. Then, the notifications would get fired from within the controller.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/tree/blog-article/samples/MvcSample&#34;&gt;find the sample on GitHub, in the &lt;code&gt;MvcSample&lt;/code&gt; folder&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will build a standard MVC application and we will add the &lt;code&gt;WebSocketManagerMiddleware&lt;/code&gt; we created. &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/blog-article/samples/MvcSample/Startup.cs&#34;&gt;Here&amp;rsquo;s the &lt;code&gt;Startup&lt;/code&gt; class of this application&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class Startup
    {
        public void Configure(IApplicationBuilder app, IServiceProvider serviceProvider)
        {
            app.UseStaticFiles();
            app.UseWebSockets();

            app.UseMvc(routes =&amp;gt;
            {
                routes.MapRoute(
                    name: &amp;quot;default&amp;quot;,
                    template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
                );
            });

            app.MapWebSocketManager(&amp;quot;/notifications&amp;quot;, serviceProvider.GetService&amp;lt;NotificationsMessageHandler&amp;gt;());
        }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddWebSocketManager();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this time the handler class only manages the connected clients and will not handle requests itself, we can leave the &lt;code&gt;ReceiveAsync&lt;/code&gt; method unimplemented:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class NotificationsMessageHandler : WebSocketHandler
    {
        public NotificationsMessageHandler(WebSocketConnectionManager webSocketConnectionManager) : base(webSocketConnectionManager)
        {
        }

        public override Task ReceiveAsync(WebSocket socket, WebSocketReceiveResult result, byte[] buffer)
        {
            throw new NotImplementedException();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the controller:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class MessagesController : Controller
    {
        private NotificationsMessageHandler _notificationsMessageHandler { get; set; }

        public MessagesController(NotificationsMessageHandler notificationsMessageHandler)
        {
            _notificationsMessageHandler = notificationsMessageHandler;
        }

        [HttpGet]
        public async Task SendMessage([FromQueryAttribute]string message)
        {
           await _notificationsMessageHandler.SendMessageToAllAsync(message);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the controller we will have a &lt;code&gt;NotificationsMessageHandler&lt;/code&gt; instance that will handle the sending of notifications to all connected clients.&lt;/p&gt;

&lt;p&gt;The HTML page is very similar to the previous ones, but this time the message will be sent using the API we created, so through HTTP and not WebSockets, so basically only the &lt;code&gt;sendMessage&lt;/code&gt; method is different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        function sendMessage(message) { 
            console.log(&amp;quot;Sending: &amp;quot; + message);
            
            $.ajax({
                url: &amp;quot;http://&amp;quot; + window.location.host + &amp;quot;/api/messages/sendmessage?message=&amp;quot; + message,
                method: &#39;GET&#39;
            });
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice I only added &lt;code&gt;jQuery&lt;/code&gt; so the HTTP request would be simpler (using &lt;code&gt;AJAX&lt;/code&gt;), it has noting to do with the WebSockets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s see how it works:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/mvc-sample.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Basically, the user doesn&amp;rsquo;t see any difference, but the client is sending data through an HTTP request and receiving it through WebSockets.&lt;/p&gt;

&lt;h2 id=&#34;extra-console-client&#34;&gt;Extra - Console client&lt;/h2&gt;

&lt;p&gt;You can also use a C# console client to connect to the application we created.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/radu-matei/websocket-manager/blob/blog-article/samples/EchoConsoleClient/Program.cs&#34;&gt;find the source code of this sample on GitHub here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that this console client is pretty much &lt;a href=&#34;https://github.com/aspnet/SignalR/blob/dev/samples/WebSocketSample/Program.cs&#34;&gt;a clone of a WebSocket sample from the SignalR repository&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This sample uses the &lt;code&gt;System.Net.WebSockets&lt;/code&gt; namespace which contains the &lt;code&gt;ClientWebSocket&lt;/code&gt; class (pretty weird name if you ask me).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Net.WebSockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace EchoConsoleClient
{
    public class Program
    {
        public static void Main(string[] args)
        {
            RunWebSockets().GetAwaiter().GetResult();
        }

        private static async Task RunWebSockets()
        {
            var client = new ClientWebSocket();
            await client.ConnectAsync(new Uri(&amp;quot;ws://localhost:5000/test&amp;quot;), CancellationToken.None);

            Console.WriteLine(&amp;quot;Connected!&amp;quot;);

            var sending = Task.Run(async() =&amp;gt; 
            {
                string line;
                while((line = Console.ReadLine()) != null &amp;amp;&amp;amp; line != String.Empty)
                {
                    var bytes = Encoding.UTF8.GetBytes(line);

                    await client.SendAsync(new ArraySegment&amp;lt;byte&amp;gt;(bytes), WebSocketMessageType.Text, true, CancellationToken.None);
                }

                await client.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, &amp;quot;&amp;quot;, CancellationToken.None);
            });

            var receiving = Receiving(client);

            await Task.WhenAll(sending, receiving);
        }

        private static async Task Receiving(ClientWebSocket client)
        {
            var buffer = new byte[1024 * 4];

            while(true)
            {
                var result = await client.ReceiveAsync(new ArraySegment&amp;lt;byte&amp;gt;(buffer), CancellationToken.None);

                if(result.MessageType == WebSocketMessageType.Text)
                    Console.WriteLine(Encoding.UTF8.GetString(buffer, 0, result.Count));

                else if(result.MessageType == WebSocketMessageType.Close)
                {
                    await client.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, &amp;quot;&amp;quot;, CancellationToken.None);
                    break;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point there is no high level client for WebSockets, so this is how you manage the connection from the client perspective.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that both the Chat application and this console client sample must be running.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://radu-matei.github.io/img/article-photos/aspnet-core-websockets-middleware/console-sample.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that in order for a Terminal console to appear when starting the application you need to set the &lt;code&gt;&amp;quot;externalConsole&amp;quot;: true&lt;/code&gt; in &lt;code&gt;launch.json&lt;/code&gt; in VS Code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;In the first place, I should investigate why Kestrel throws an exception when this is the last middleware in the pipeline (maybe it is the intended behaviour?). Then, I should also decide wether I have to create a class that wraps the socket ID and the socket itself in a single object (not sure wether I need this or not).&lt;/p&gt;

&lt;p&gt;Another thing I want to do is to see if there is a way to know wether a middleware has been added to the pipeline (so I place &lt;code&gt;app.UseWebSockets()&lt;/code&gt; in the extension method and not have the user add it). I know that &lt;a href=&#34;https://github.com/aspnet/HttpAbstractions/blob/master/src/Microsoft.AspNetCore.Http/Internal/ApplicationBuilder.cs/#L16&#34;&gt;there is a private field on &lt;code&gt;ApplicationBuilder&lt;/code&gt; called &lt;code&gt;_components&lt;/code&gt; that holds all added middleware, but it is not accessible from &lt;code&gt;app&lt;/code&gt;&lt;/a&gt;, and also understand what happens if you add the same middleware twice.&lt;/p&gt;

&lt;p&gt;This started as a fun side project (and I am pretty sure it will stay this way once SignalR becomes ready for production). Still, if I found the time, I would love to &lt;strong&gt;implement the client and server calling each others&amp;rsquo; methods bit from SignalR&lt;/strong&gt;. I find it to be really cool and think there are some cool things to learn from there.&lt;/p&gt;

&lt;p&gt;And last but not least, I will investigate sending JSON objects as messages rather than simple strings and the necessity of writing JavaScript and C# clients. Most likely that won&amp;rsquo;t happen, but it would be nice if I had the time.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s take a step back and see what we have done:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we&amp;rsquo;ve started by investigating the &lt;code&gt;WebSocekts&lt;/code&gt; package from ASP .NET Core&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve taken a look at ASP .NET Core middleware&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve written a connection manager for WebSocket connections&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve written an abstract handler class that deals with connection and disconnection events, while also sending and receiving messages&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve built the actual middleware&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ve added some extension methods to register services and add the middleware in the pipeline&lt;/li&gt;
&lt;li&gt;then we built some samples that demonstrate:

&lt;ul&gt;
&lt;li&gt;how to write a pure-sockets chat application&lt;/li&gt;
&lt;li&gt;how to integrate this middleware with MVC and send notifications to connected clients&lt;/li&gt;
&lt;li&gt;how to build a very simple console client written in C#&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;feedback-wanted&#34;&gt;Feedback wanted&lt;/h2&gt;

&lt;p&gt;If you stumbled upon this article, please take a moment and provide some feedback both on the middleware itself and on the way the article is written. Any feedback is immensely appreciated, as well as questions and observations.&lt;/p&gt;

&lt;p&gt;Also, if you want to &lt;a href=&#34;https://github.com/radu-matei/websocket-manager&#34;&gt;contribute to this middleware, you can find the repository on GitHub&lt;/a&gt;. Any contribution is greatly appreciated.&lt;/p&gt;

&lt;h2 id=&#34;thanks-for-reading&#34;&gt;Thanks for reading! :)&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>ASP.NET Core MVC and SignalR Core</title>
      <link>http://radu-matei.github.io/blog/aspnet-core-mvc-signalr/</link>
      <pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/aspnet-core-mvc-signalr/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this article we will take a look at how to integrate ASP.NET Core MVC with SignalR Core (at the moment of writing this article, the latest version of SignalR is &lt;a href=&#34;https://dotnet.myget.org/feed/aspnetcore-ci-dev/package/nuget/Microsoft.AspNetCore.SignalR.Server&#34;&gt;&lt;code&gt;0.2.0-alpha1-22107&lt;/code&gt;&lt;/a&gt;) and how to use the SignalR context outside hubs (and solve the current issues with the custom resolvers that will be detailed later) to update clients.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This article assumes a basic understanding of ASP.NET Core MVC and will not try to explain all concepts here. &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-api/&#34;&gt;This article&lt;/a&gt; does an introduction to ASP.NET Core MVC and has the basic application structure needed for this article.&lt;/p&gt;

&lt;p&gt;In order to get started with SignalR Core, &lt;a href=&#34;https://radu-matei.github.io/blog/signalr-core/&#34;&gt;take a look at this article&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will build on &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-api/&#34;&gt;this application&lt;/a&gt; and add real time functionality to it.&lt;/p&gt;

&lt;p&gt;It is a very simple application that will enable the creation of posts (much like messages) and it took us through adding the MVC services, creating models, controllers and consuming some data. Now, we want all connected users to see in real time when somebody adds posts in the page without refreshing it.&lt;/p&gt;

&lt;h2 id=&#34;configure-the-application&#34;&gt;Configure the application&lt;/h2&gt;

&lt;p&gt;NuGet has the ability to get packages from more than one source, and we need it to download alpha packages that are only available on the MyGet server of the ASP.NET team, besides the ASP.NET Core packages available on NuGet. So in the root of the application add a file called &lt;code&gt;NuGet.Config&lt;/code&gt; with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;packageSources&amp;gt;
        &amp;lt;clear/&amp;gt;
            &amp;lt;add key=&amp;quot;aspnetcidev&amp;quot; value=&amp;quot;https://dotnet.myget.org/F/aspnetcore-ci-dev/api/v3/index.json&amp;quot;/&amp;gt;
            &amp;lt;add key=&amp;quot;api.nuget.org&amp;quot; value=&amp;quot;https://api.nuget.org/v3/index.json&amp;quot;/&amp;gt;
    &amp;lt;/packageSources&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;add-the-required-packages&#34;&gt;Add the required packages&lt;/h2&gt;

&lt;p&gt;For this application, we will need the Kestrel web server (of course), the MVC packages so we can use controllers, static files so we can have HTML and JavaScript files served, SignalR and WebSockets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.Mvc&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.SignalR.Server&amp;quot;: &amp;quot;0.2.0-*&amp;quot;,
&amp;quot;Microsoft.AspNetCore.WebSockets&amp;quot;: &amp;quot;0.2.0-*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;program-cs&#34;&gt;&lt;code&gt;Program.cs&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Besides adding the &lt;code&gt;UseContentRoot&lt;/code&gt; statement, the &lt;code&gt;Main&lt;/code&gt; method is pretty much standard for an ASP.NET Core application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; public static void Main(string[] args)
 {
     var host = new WebHostBuilder()
         .UseKestrel()
         .UseContentRoot(Directory.GetCurrentDirectory())
         .UseStartup&amp;lt;Startup&amp;gt;()
         .Build();

     host.Run();
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;post-ipostrepository-and-postrepository&#34;&gt;&lt;code&gt;Post&lt;/code&gt;, &lt;code&gt;IPostRepository&lt;/code&gt; and &lt;code&gt;PostRepository&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-api/&#34;&gt;This article&lt;/a&gt; explains all these components thoroughly, but let&amp;rsquo;s see briefly what each one does:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Post
{
    public int Id { get; set; }
    public string UserName { get; set; }
    public string Text { get; set; }

    public Post(int id, string userName, string text)
    {
        Id = id;
        UserName = userName;
        Text = text;
    }

    public Post()
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Post&lt;/code&gt; will be the model that users add in the application. It is a straightforward C# class with three auto-implemented properties and two constructors.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each user that enters can publish a post containing his user name and a text, so our Post class only contains two properties for the UserName and Text of the post and an Id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;

public interface IPostRepository
{
    List&amp;lt;Post&amp;gt; GetAll();
    Post GetPost(int id);
    void AddPost(Post post);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Regardless of where that data is going to be stored, there should be a consistent way of reading and writing, and we will achieve this through an interface, IPostRepository, that will expose the minimum necessary methods: a method to read all posts, a method to add a post and a method to retrieve a post with a specified id.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Linq;

public class PostRepository : IPostRepository
{
    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
    public void AddPost(Post post)
    {
        _posts.Add(post);
    }

    public List&amp;lt;Post&amp;gt; GetAll()
    {
        return _posts;
    }

    public Post GetPost(int id)
    {
        return _posts.FirstOrDefault(p =&amp;gt; p.Id == id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We implemented the &lt;code&gt;IPostRepository&lt;/code&gt; interface through an in-memory class called &lt;code&gt;PostRepository&lt;/code&gt; that holds the data in a list. Since we have the three methods to access the data, there is no need to expose the post list outside the class, so it is be private. Besides the list, we only need to implement the three methods from the interface.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-postscontroller&#34;&gt;The &lt;code&gt;PostsController&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR.Infrastructure;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }

    public PostsController(IPostRepository postRepository)
    {
        _postRepository = postRepository;
    }

    [HttpGet]
    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    [HttpGet]
    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    [HttpPost]
    public void AddPost(Post post)
    {
        _postRepository.AddPost(post);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this controller, we will update all clients when a post was added using SignalR by getting the context of the hub and calling client methods  using a &lt;code&gt;ConnectionManager&lt;/code&gt;. We will see later how to achieve this.&lt;/p&gt;

&lt;h2 id=&#34;add-a-hub&#34;&gt;Add a hub&lt;/h2&gt;

&lt;p&gt;In this application, we will use the hub as a proxy: clients will not call hub methods directly. SignalR will be used to provide server updates - that is the server notifies all clients that something happened, so the clients must first connect to a hub.&lt;/p&gt;

&lt;p&gt;So the hub class will be incredibly simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.SignalR;

public class PostsHub : Hub
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will see how to use the hub context outside of the hub a little later.&lt;/p&gt;

&lt;h2 id=&#34;camel-case-issues-and-custom-contract-resolvers&#34;&gt;Camel case issues and custom contract resolvers&lt;/h2&gt;

&lt;p&gt;At this moment, MVC uses camel case notation to pass JSON to clients. That means that even if on the server you write your class properties with Pascal case notation (as you should!), JavaScript clients would get Camel cased objects.&lt;/p&gt;

&lt;p&gt;This behavior is new to ASP.NET Core and was not present in the older versions when SignalR was used and built, so SignalR and its clients all expect Pascal case objects, while the objects passed between MVC and its clients are camel cased. This means we cannot reuse metods across the JavaScript client, thing we cannot tolerate.&lt;/p&gt;

&lt;p&gt;So we are going to make SignalR pass objects in camel case. Basically, we are going to &amp;ldquo;recycle&amp;rdquo; &lt;a href=&#34;https://github.com/SignalR/SignalR/issues/500#issuecomment-7453751&#34;&gt;this old SignalR GitHub issue&lt;/a&gt; and adapt it to our versions of ASP.NET and SignalR.&lt;/p&gt;

&lt;h2 id=&#34;add-a-custom-contract-resolvers&#34;&gt;Add a custom contract resolvers&lt;/h2&gt;

&lt;p&gt;A first try could be to change the default contract resolver to a &lt;code&gt;CamelCasePropertyNamesContractResolver()&lt;/code&gt; inside the &lt;code&gt;ConfigureServices&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var settings = new JsonSerializerSettings();
settings.ContractResolver = new CamelCasePropertyNamesContractResolver();

var serializer = JsonSerializer.Create(settings);
services.Add(new ServiceDescriptor(typeof(JsonSerializer), 
             provider =&amp;gt; serializer, 
             ServiceLifetime.Transient));

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While this is not far from what we are going to do, at this moment we simply cannot force all components to pass camel case objects because it would break current conventions in place.&lt;/p&gt;

&lt;p&gt;Simply put, if you try this the JavaScript client will no longer connect, because all connection and internal communication is tansformed to camel case.&lt;/p&gt;

&lt;p&gt;We are at the point where we need all of the application objects to be passed camel cased, and all connection and SignalR internal objects to be unmodified.&lt;/p&gt;

&lt;p&gt;We will write a custom contract resolver that looks at the assembly of the object type and if it is not an internal SignalR object (if it is not from the same assembly as &lt;code&gt;Connection&lt;/code&gt;, a class from SignalR), then it modifies it to be camel case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Reflection;
using Microsoft.AspNetCore.SignalR.Infrastructure;
using Newtonsoft.Json.Serialization;

    public class SignalRContractResolver : IContractResolver
    {
        private readonly Assembly _assembly;
        private readonly IContractResolver _camelCaseContractResolver;
        private readonly IContractResolver _defaultContractSerializer;

        public SignalRContractResolver()
        {
            _defaultContractSerializer = new DefaultContractResolver();
            _camelCaseContractResolver = new CamelCasePropertyNamesContractResolver();
            _assembly = typeof(Connection).GetTypeInfo().Assembly;
        }


        public JsonContract ResolveContract(Type type)
        {
            if (type.GetTypeInfo().Assembly.Equals(_assembly))
                return _defaultContractSerializer.ResolveContract(type);

            return _camelCaseContractResolver.ResolveContract(type);
        }

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So in &lt;code&gt;ConfigureServices&lt;/code&gt; we register our contract resolver very similarly to what we had earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var settings = new JsonSerializerSettings();
settings.ContractResolver = new SignalRContractResolver();

var serializer = JsonSerializer.Create(settings);
services.Add(new ServiceDescriptor(typeof(JsonSerializer), 
             provider =&amp;gt; serializer, 
             ServiceLifetime.Transient));
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that most likely, this will be done more elegantly in future releases.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-configure-method&#34;&gt;The &lt;code&gt;Configure&lt;/code&gt; method&lt;/h2&gt;

&lt;p&gt;Again, the &lt;code&gt;Configure&lt;/code&gt; method is pretty straightforward: we add static files support, configure MVC and add WebSockets and SignalR.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseStaticFiles();

        app.UseMvc(routes =&amp;gt; 
        {
            routes.MapRoute(
                    name: &amp;quot;default&amp;quot;,
                    template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });

        app.UseWebSockets();
        app.UseSignalR();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;calling-client-methods-outside-hubs&#34;&gt;Calling client methods outside hubs&lt;/h2&gt;

&lt;p&gt;In the previous versions of SignalR, in order to call client methods and manage groups outside a hub you would need to make use of the &lt;code&gt;GlobalHost&lt;/code&gt;, which is no longer available in the new version.&lt;/p&gt;

&lt;p&gt;So we will use an instance of &lt;code&gt;ConnectionManager&lt;/code&gt;, specifically the &lt;code&gt;GetHubContext&amp;lt;&amp;gt;()&lt;/code&gt; method. We need to register this service so we can use it in the controller:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_connectionManager.GetHubContext&amp;lt;PostsHub&amp;gt;().someClientMethod(parameters)&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-configureservices-method&#34;&gt;The &lt;code&gt;ConfigureServices&lt;/code&gt; method&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        var settings = new JsonSerializerSettings();
        settings.ContractResolver = new SignalRContractResolver();

        var serializer = JsonSerializer.Create(settings);

        services.Add(new ServiceDescriptor(typeof(JsonSerializer), 
                     provider =&amp;gt; serializer, 
                     ServiceLifetime.Transient));

        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();

        services.AddSignalR(options =&amp;gt; 
        {
            options.Hubs.EnableDetailedErrors = true;
        });
        
        services.AddMvc();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We added the new contract resolver, we added the &lt;code&gt;PostRepository&lt;/code&gt; and we added SignalR. Now we need to use it in the controller:&lt;/p&gt;

&lt;h2 id=&#34;the-updated-controller&#34;&gt;The updated controller&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.SignalR.Infrastructure;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }
    private IConnectionManager _connectionManager {get; set; }

    public PostsController(IPostRepository postRepository, IConnectionManager connectionManager)
    {
        _postRepository = postRepository;
        _connectionManager = connectionManager;
    }

    [HttpGet]
    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    [HttpGet]
    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    [HttpPost]
    public void AddPost(Post post)
    {
        _postRepository.AddPost(post);
        _connectionManager.GetHubContext&amp;lt;PostsHub&amp;gt;().Clients.All.publishPost(post);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time someone adds a new post, all connected users will be notified and will call the &lt;code&gt;publishPost&lt;/code&gt; method.&lt;/p&gt;

&lt;h2 id=&#34;the-client&#34;&gt;The client&lt;/h2&gt;

&lt;p&gt;The client will be exactly the same as in SignalR 2.2.x:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;

    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.2.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/signalr/jquery.signalr-2.2.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;/signalr/hubs&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    
    &amp;lt;input id=&amp;quot;userNameInput&amp;quot; type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Enter your user name...&amp;quot; /&amp;gt;
    &amp;lt;input id=&amp;quot;textInput&amp;quot; type=&amp;quot;text&amp;quot; placeholder=&amp;quot;Enter your status...&amp;quot; /&amp;gt;

    &amp;lt;button id=&amp;quot;publishPostButton&amp;quot;&amp;gt;Publish post!&amp;lt;/button&amp;gt;

    &amp;lt;ul id=&amp;quot;postsList&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
    
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
        $.ajax({
            url: &#39;/api/Posts/GetPosts&#39;,
            method: &#39;GET&#39;,
            dataType: &#39;JSON&#39;,
            success: addPostsList
        });

        function addPostsList(posts) {
            $.each(posts, function (index) {
                var post = posts[index];
                addPost(post);
            });
        }

        function addPost(post) {
            $(&amp;quot;#postsList&amp;quot;).append(
                    &#39;&amp;lt;li&amp;gt;&amp;lt;b&amp;gt;&#39; + post.userName + &#39;&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;&#39; + post.text + &#39;&amp;lt;/li&amp;gt;&amp;lt;br&amp;gt;&#39;
                 );
        }

        var hub = $.connection.postsHub;

        hub.client.publishPost = addPost;

        $(&amp;quot;#publishPostButton&amp;quot;).click(function () {

            var post = {
                userName: $(&amp;quot;#userNameInput&amp;quot;).val() || &amp;quot;Guest&amp;quot;,
                text: $(&amp;quot;#textInput&amp;quot;).val()
            };
            $.ajax({
                url: &#39;/api/Posts/AddPost&#39;,
                method: &#39;POST&#39;,
                data: post
            });
        });
        
        $.connection.hub.logging = true;
        $.connection.hub.start();
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you open two browser tabs and start adding messages, you can see all pages updating in real time.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this article we saw how to use MVC Core and SignalR for providing real time data to users.&lt;/p&gt;

&lt;p&gt;Since SignalR is still in alpha, at this moment there are some issues to be addressed and many breaking changes to come and I will try to keep this example up-to-date.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with SignalR Core</title>
      <link>http://radu-matei.github.io/blog/signalr-core/</link>
      <pubDate>Wed, 07 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://radu-matei.github.io/blog/signalr-core/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;ASP.NET SignalR is a library for ASP.NET developers that simplifies the process of adding real-time web functionality to applications. Real-time web functionality is the ability to have server code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The 1.0.0 version of ASP.NET Core didn&amp;rsquo;t include a version of SignalR, so the team plans to release SignalR in the 1.2 iteration of the framework with some functionality that should make any SignalR developer happy: rewrite of the JavaScript client using TypeScript without the jQuery dependency, no more &lt;code&gt;GlobalHost&lt;/code&gt; and integration with the dependency injection engine from ASP.NET Core, remove the forever frame transport completely or support binary transfer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For the complete discussion for the SignalR planning, &lt;a href=&#34;https://github.com/aspnet/SignalR-Server/issues/196&#34;&gt;see this issue on the GitHub repository&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Since we are almost a year away from the official release of the framework, everything you are about to see is by no means production ready and will most likely suffer breaking changes over time. I will try to keep this article up-to-date with the various changes that will take place around SignalR over time.&lt;/p&gt;

&lt;p&gt;At this moment, there is a &lt;code&gt;0.2.0&lt;/code&gt; alpha version of &lt;a href=&#34;https://dotnet.myget.org/feed/aspnetcore-dev/package/nuget/Microsoft.AspNetCore.SignalR.Server&#34;&gt;&lt;code&gt;Microsoft.AspNetCore.SignalR.Server&lt;/code&gt;&lt;/a&gt; that makes it possible to use SignalR with an ASP.NET Core application, but it doesn&amp;rsquo;t implement the changes mentioned above just yet and you still use the same JavaScript client with the jQuery dependency.&lt;/p&gt;

&lt;h2 id=&#34;adding-nuget-config&#34;&gt;Adding NuGet.Config&lt;/h2&gt;

&lt;p&gt;In order to get access to the development packages of SignalR (of any package, really), we need to add a &lt;code&gt;NuGet.Config&lt;/code&gt; file that allows NuGet to get packages from multiple sources, in our case from the ASP.NET continous integration server from MyGet.&lt;/p&gt;

&lt;p&gt;In the same folder as &lt;code&gt;Program.cs&lt;/code&gt; and &lt;code&gt;Startup.cs&lt;/code&gt;, add a &lt;code&gt;NuGet.Config&lt;/code&gt; file with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;packageSources&amp;gt;
        &amp;lt;clear/&amp;gt;
            &amp;lt;add key=&amp;quot;aspnetcidev&amp;quot; value=&amp;quot;https://dotnet.myget.org/F/aspnetcore-ci-dev/api/v3/index.json&amp;quot;/&amp;gt;
            &amp;lt;add key=&amp;quot;api.nuget.org&amp;quot; value=&amp;quot;https://api.nuget.org/v3/index.json&amp;quot;/&amp;gt;
    &amp;lt;/packageSources&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-the-required-packages&#34;&gt;Adding the required packages&lt;/h2&gt;

&lt;p&gt;We need to add the following packages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;:&amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.StaticFiles&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;Microsoft.AspNetCore.SignalR.Server&amp;quot;: &amp;quot;0.2.0-*&amp;quot;,
&amp;quot;Microsoft.AspNetCore.WebSockets&amp;quot;: &amp;quot;0.2.0-*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configure-the-application&#34;&gt;Configure the application&lt;/h2&gt;

&lt;p&gt;Besides the usual configuration needed for a web application, we also need to add support for serving static files. If we use the current directory, the framework will search for a directory called &lt;code&gt;wwwroot&lt;/code&gt; and serve the file from there.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        public static void Main(string[] args)
        {
            var host = new WebHostBuilder()
                .UseKestrel()
                .UseContentRoot(Directory.GetCurrentDirectory())
                .UseStartup&amp;lt;Startup&amp;gt;()
                .Build();

            host.Run();
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need to add the required services in &lt;code&gt;Startup&lt;/code&gt;. In the &lt;code&gt;ConfigureServices&lt;/code&gt; method we need to &lt;code&gt;AddSignalR&lt;/code&gt;, with support for detailed errors in the browser console.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSignalR(options =&amp;gt; 
        {
            options.Hubs.EnableDetailedErrors = true;
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in the &lt;code&gt;Configure&lt;/code&gt; method, we need to serve static files, use websockets and use SignalR:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseStaticFiles();
        app.UseWebSockets();
        app.UseSignalR();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At this moment, in order to get the framework to use websockets, you need to add &lt;code&gt;app.UseWebSockets()&lt;/code&gt;. If you don&amp;rsquo;t add the websockets support in your application, the transport will fall back to the next available transport.&lt;/p&gt;

&lt;p&gt;According to &lt;a href=&#34;https://github.com/aspnet/SignalR-Server/issues/220&#34;&gt;this GitHub issue&lt;/a&gt;, it is still not decided wether you will need to add the websockets reference as a separate operation or if it will be included in the &lt;code&gt;AddSignalR()&lt;/code&gt; call.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point, you can add &lt;code&gt;Hub&lt;/code&gt; classes and JavaScript clients in exactly the same way as for &lt;code&gt;2.2.0&lt;/code&gt; or &lt;code&gt;2.2.1&lt;/code&gt;. Note that in future releases this will most likely be different, as changes in the client start appearing.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-hub-class&#34;&gt;Adding a Hub class&lt;/h2&gt;

&lt;p&gt;The very simple example here, as it is very common in the case of SignalR, a chat :)&lt;/p&gt;

&lt;p&gt;We have a &lt;code&gt;Connect&lt;/code&gt; method used to add a user to a connected users list and a &lt;code&gt;Send&lt;/code&gt; method that sends a message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ChatHub : Hub
    {
        public static List&amp;lt;string&amp;gt; ConnectedUsers;

        public void Send(string originatorUser, string message)
        {
            Clients.All.messageReceived(originatorUser, message);
        }

        public void Connect(string newUser)
        {
            if (ConnectedUsers == null)
                ConnectedUsers = new List&amp;lt;string&amp;gt;();

            ConnectedUsers.Add(newUser);
            Clients.Caller.getConnectedUsers(ConnectedUsers);
            Clients.Others.newUserAdded(newUser);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To keep things simple I didn&amp;rsquo;t use the &lt;code&gt;OnConnected&lt;/code&gt; override here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-the-client&#34;&gt;Adding the client&lt;/h2&gt;

&lt;p&gt;We will now create a &lt;code&gt;wwwroot&lt;/code&gt; directory that will contain all of our static files.&lt;/p&gt;

&lt;p&gt;We add a new HTML file called &lt;code&gt;chat.html&lt;/code&gt; that will simply have an unordered list for the messages, a text input and a button. As you can see, the SignalR script used here is the latest one, &lt;code&gt;2.2.1&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Awesome Chat Application&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        .userListDiv{
            float: right;
        }
    &amp;lt;/style&amp;gt;

    &amp;lt;ul id=&amp;quot;messages&amp;quot;&amp;gt;&amp;lt;/ul&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;messageBox&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;button&amp;quot; id=&amp;quot;sendMessage&amp;quot; value=&amp;quot;Send Message!&amp;quot; /&amp;gt;
    &amp;lt;div class=&amp;quot;userListDiv&amp;quot;&amp;gt;
        &amp;lt;ul id=&amp;quot;userList&amp;quot;&amp;gt; &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;http://ajax.aspnetcdn.com/ajax/signalr/jquery.signalr-2.2.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;signalr/hubs&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;chat.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also add a &lt;code&gt;chat.js&lt;/code&gt; file that contains the SignalR connection and client methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var userName = prompt(&amp;quot;Enter your name: &amp;quot;);
var chat = $.connection.chatHub;
chat.client.messageReceived = function (originatorUser, message) {
    $(&amp;quot;#messages&amp;quot;).append(&#39;&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;&#39; + originatorUser + &#39;&amp;lt;/strong&amp;gt;: &#39; + message);
};

chat.client.getConnectedUsers = function (userList) {
    for (var i = 0; i &amp;lt; userList.length; i++)
        addUser(userList[i]);
};

chat.client.newUserAdded = function (newUser) {
    addUser(newUser);
}

$(&amp;quot;#messageBox&amp;quot;).focus();

$(&amp;quot;#sendMessage&amp;quot;).click(function () {
    chat.server.send(userName, $(&amp;quot;#messageBox&amp;quot;).val());
    $(&amp;quot;#messageBox&amp;quot;).val(&amp;quot;&amp;quot;);
    $(&amp;quot;#messageBox&amp;quot;).focus();
});

$(&amp;quot;#messageBox&amp;quot;).keyup(function (event) {
    if (event.keyCode == 13)
        $(&amp;quot;#sendMessage&amp;quot;).click();
});

function addUser(user){
    $(&amp;quot;#userList&amp;quot;).append(&#39;&amp;lt;li&amp;gt;&#39; + user + &#39;&amp;lt;/li&amp;gt;&#39;);
}

$.connection.hub.logging = true;
$.connection.hub.start().done(function () {
    chat.server.connect(userName);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, ask the user for a user name, define the client methods that display messages and users and define the behaviour when clicking the button (and for pressing Enter).&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a very simple example of integrating a very early preview of SignalR Core into an ASP.NET Core application. As the framework evolves, I will try to keep this example up to date.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>