<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Radu Matei - Developer Evangelist</title>
    <link>https://radu-matei.com/categories/dependency-injection/index.xml</link>
    <description>Recent content on Radu Matei - Developer Evangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://radu-matei.com/categories/dependency-injection/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Inject ASP.NET Core Dependencies from JSON files</title>
      <link>https://radu-matei.com/blog/aspnet-core-json-dependency-injection/</link>
      <pubDate>Thu, 18 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-json-dependency-injection/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-need-for-registering-services-through-a-json-file&#34;&gt;The need for registering services through a JSON file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-required-packages&#34;&gt;Adding the required packages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-a-dummy-service&#34;&gt;Creating a dummy service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#how-to-inject-an-itest-service&#34;&gt;How to inject an &lt;code&gt;ITest&lt;/code&gt; service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-json-file&#34;&gt;The JSON file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-service-class&#34;&gt;The &lt;code&gt;Service&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-services&#34;&gt;Adding the services&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-the-application&#34;&gt;Testing the application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-startup-class&#34;&gt;The &lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Back in the days&amp;rdquo; of ASP.NET 4.x, each of the framework components (MVC, WebAPI, OWIN, SignalR) had its own dependency resolver and its own way of integrating with the framework.&lt;/p&gt;

&lt;p&gt;For example, if you had an application that used MVC/WebAPI, OWIN and SignalR and you wanted to use &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/index.html&#34;&gt;Autofac&lt;/a&gt;, you would have needed individual integrations, with different method names (see &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/integration/mvc.html#register-controllers&#34;&gt;&lt;code&gt;RegisterControllers&lt;/code&gt;&lt;/a&gt; for MVC and &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/integration/webapi.html#register-controllers&#34;&gt;&lt;code&gt;RegisterApiControllers&lt;/code&gt;&lt;/a&gt; for WebAPI), different NuGet packages (see &lt;a href=&#34;https://www.nuget.org/packages/Autofac.WebApi2/&#34;&gt;the package for WebAPI&lt;/a&gt; and &lt;a href=&#34;https://www.nuget.org/packages/Autofac.Mvc5/&#34;&gt;the package for MVC&lt;/a&gt;) and different dependency resolvers and you even needed to take care at the order in which you replaced the dependency resolvers for these components.&lt;/p&gt;

&lt;p&gt;ASP.NET Core brings a consistent dependency injection mechanism with a unified meaning for lifetime or service registration,that is designed to server the needs of the framework &amp;ldquo;and most consumer applications built on it&amp;rdquo; (&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html#replacing-the-default-services-container&#34;&gt;as the documentation states&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Of course, you can replace the default DI engine that comes with the framework and use &lt;a href=&#34;http://autofac.readthedocs.io/en/latest/integration/aspnetcore.html&#34;&gt;Autofac&lt;/a&gt;, &lt;a href=&#34;https://www.nuget.org/packages/DryIoc.Microsoft.DependencyInjection&#34;&gt;Dryloc&lt;/a&gt;, &lt;a href=&#34;https://www.nuget.org/packages/Grace.DependencyInjection.Extensions&#34;&gt;Grace&lt;/a&gt;, &lt;a href=&#34;https://github.com/seesharper/LightInject.Microsoft.DependencyInjection&#34;&gt;LightInject&lt;/a&gt; or &lt;a href=&#34;https://github.com/structuremap/StructureMap.Microsoft.DependencyInjection&#34;&gt;StructureMap&lt;/a&gt; and in a future article, we will probably explore a couple of them.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In this article, we will see a way of defining the service types and the implementation types we want to use based on a JSON file and switch between implementations without changing the code.&lt;/p&gt;

&lt;p&gt;This is a feature in Autofac for ASP.NET and you can &lt;a href=&#34;http://docs.autofac.org/en/latest/configuration/xml.html&#34;&gt;find it documented here&lt;/a&gt;, but we will implement a very basic way of adding services using only the built-in mechanism.&lt;/p&gt;

&lt;p&gt;Also, it will not use the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-configuration-greeting/&#34;&gt;JSON configuration provider&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-need-for-registering-services-through-a-json-file&#34;&gt;The need for registering services through a JSON file&lt;/h2&gt;

&lt;p&gt;A very simple reason to think about using a JSON file when registering DI services is because you might not know (or cannot choose) the concrete implementation at compile-time.&lt;/p&gt;

&lt;p&gt;Another reason could be for switching implementations for testing purposes.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can also &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/environments.html&#34;&gt;work with multiple environments&lt;/a&gt; and have &lt;code&gt;Startup{EnvironmentName}&lt;/code&gt; class for each environment - dev, testing, production and set the environment variable before running the application.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But for this article, I thought it would be cool to inject the required dependencies based on a JSON file without using any DI engine other than the built-in one from ASP.NET Core.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-required-packages&#34;&gt;Adding the required packages&lt;/h2&gt;

&lt;p&gt;Since this is going to be a web app, we need the Kestrel web server package (Microsoft.AspNetCore.Server.Kestrel). As I said earlier, we are not going to use the JSON Configuration provider (at this point), so we will only need a library to deserialize (part of) JSON, and we will use Newtonsoft.Json.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-dummy-service&#34;&gt;Creating a dummy service&lt;/h2&gt;

&lt;p&gt;We are going to need a very simple service to inject in our application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface ITest
{
    string DoSomething(string parameter);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And an even simpler implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test : ITest
{
    public string DoSomething(string parameter)
    {
        return $&amp;quot;Message from Test with { parameter }&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-to-inject-an-itest-service&#34;&gt;How to inject an &lt;code&gt;ITest&lt;/code&gt; service&lt;/h2&gt;

&lt;p&gt;In order to inject a service of type &lt;code&gt;ITest&lt;/code&gt;, you need to add a function in &lt;code&gt;Startup&lt;/code&gt; called &lt;code&gt;ConfigureServices&lt;/code&gt; that has a parameter of type &lt;code&gt;ISerciceCollection&lt;/code&gt; and add the service in this collection.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.Add(new ServiceDescriptor(serviceType: typeof(ITest), 
                                       implementationType: typeof(Test), 
                                       lifetime: ServiceLifetime.Transient));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, every time a component will request an instance of &lt;code&gt;ITest&lt;/code&gt;, the framework will provide &lt;em&gt;another&lt;/em&gt; instance of &lt;code&gt;Test&lt;/code&gt;, since the lifetime is passed as &lt;em&gt;Transient&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html&#34;&gt;Transient objects are always different; a new instance is provided to every controller and every service.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-json-file&#34;&gt;The JSON File&lt;/h2&gt;

&lt;p&gt;Since we will use a JSON file, it might as well be the one we use for other configurations (or a completely different one). Regardless of what you choose, you can extract only the relevant part of the JSON file using a section name.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;services&amp;quot;: [
        {
            &amp;quot;serviceType&amp;quot;: &amp;quot;ITest&amp;quot;,
            &amp;quot;implementationType&amp;quot;: &amp;quot;Test&amp;quot;,
            &amp;quot;lifetime&amp;quot;: &amp;quot;Transient&amp;quot;
        }
    ],

    &amp;quot;otherConfigurations&amp;quot;: {
        &amp;quot;someKey&amp;quot;: &amp;quot;someValue&amp;quot;,
        &amp;quot;otherKey&amp;quot;: &amp;quot;otherValue&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the JSON section we are interested in is &lt;code&gt;services&lt;/code&gt;. At this key, we have an array of JSON objects with 3 properties: &lt;code&gt;serviceType&lt;/code&gt;, &lt;code&gt;implementationType&lt;/code&gt; and &lt;code&gt;lifetime&lt;/code&gt;, which correspond to the parameters passed to the &lt;code&gt;ServiceDescriptor&lt;/code&gt; when adding the service.&lt;/p&gt;

&lt;h2 id=&#34;the-service-class&#34;&gt;The &lt;code&gt;Service&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;These 3 properties are mapped into a class called &lt;code&gt;Service&lt;/code&gt;. For simplicity, the &lt;code&gt;ServiceType&lt;/code&gt; and &lt;code&gt;ImplementationType&lt;/code&gt; propeties are of type &lt;code&gt;string&lt;/code&gt;, but you can always implement a &lt;code&gt;JsonConverter&lt;/code&gt; that maps them to the type &lt;code&gt;Type&lt;/code&gt; (There is no immediate conversion from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;Type&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;Newtonsoft&lt;/code&gt; has implemented the conversion from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;enum&lt;/code&gt;, we used it here to convert to &lt;code&gt;ServiceLifetime&lt;/code&gt; enum from &lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

public class Service
{
    public string ServiceType { get; set; }

    public string ImplementationType { get;set; }

    [JsonConverter(typeof(StringEnumConverter))]
    public ServiceLifetime Lifetime { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-the-services&#34;&gt;Adding the services&lt;/h2&gt;

&lt;p&gt;Next, in the &lt;code&gt;Startup&lt;/code&gt; class we will simply deserialize the JSON section into a &lt;code&gt;List&amp;lt;Service&amp;gt;&lt;/code&gt;, iterate through it and add the services:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void ConfigureJsonServices(IServiceCollection services)
{
    var jsonServices = JObject.Parse(File.ReadAllText(&amp;quot;appSettings.json&amp;quot;))[&amp;quot;services&amp;quot;];
    var requiredServices = JsonConvert.DeserializeObject&amp;lt;List&amp;lt;Service&amp;gt;&amp;gt;(jsonServices.ToString());

    foreach(var service in requiredServices)
    {
         services.Add(new ServiceDescriptor(serviceType: Type.GetType(service.ServiceType),
                                            implementationType: Type.GetType(service.ImplementationType),
                                            lifetime: service.Lifetime));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, in the &lt;code&gt;ConfigureServices&lt;/code&gt; method, call this method with the &lt;code&gt;services&lt;/code&gt; argument.&lt;/p&gt;

&lt;h2 id=&#34;testing-the-application&#34;&gt;Testing the application&lt;/h2&gt;

&lt;p&gt;The first thing we can do is to add a breakpoint after executing the &lt;code&gt;ConfigureJsonServices&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-json-dependency-injection/services-breakpoint.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that our &lt;code&gt;ITest&lt;/code&gt; service was added and now we can inject it anywhere in our application.&lt;/p&gt;

&lt;p&gt;At this point, we can also inject an instance of the service in the &lt;code&gt;Configure&lt;/code&gt; method and have a message returned from the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app, ITest test)
    {
        app.Run(context =&amp;gt;
        {
            var response = test.DoSomething(&amp;quot;startup&amp;quot;);
            return context.Response.WriteAsync(response);
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time you need to provide another implementation for a service, you don&amp;rsquo;t have to recompile the entire application, simply modify the JSON file and start the application again.&lt;/p&gt;

&lt;h2 id=&#34;the-startup-class&#34;&gt;The &lt;code&gt;Startup&lt;/code&gt; class&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.IO;
using System.Collections.Generic;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        ConfigureJsonServices(services);
    }

    public void Configure(IApplicationBuilder app, ITest test)
    {
        app.Run(context =&amp;gt;
        {
            var response = test.DoSomething(&amp;quot;startup&amp;quot;);
            return context.Response.WriteAsync(response);
        });
    }

    private void ConfigureJsonServices(IServiceCollection services)
    {
        var jsonServices = JObject.Parse(File.ReadAllText(&amp;quot;appSettings.json&amp;quot;))[&amp;quot;services&amp;quot;];
        var requiredServices = JsonConvert.DeserializeObject&amp;lt;List&amp;lt;Service&amp;gt;&amp;gt;(jsonServices.ToString());

        foreach(var service in requiredServices)
        {
            services.Add(new ServiceDescriptor(serviceType: Type.GetType(service.ServiceType),
                                               implementationType: Type.GetType(service.ImplementationType),
                                               lifetime: service.Lifetime));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a very basic and rudimentary way of injecting dependencies in the application. It is by no means production ready, it doesn&amp;rsquo;t deal with exceptions, services that don&amp;rsquo;t exist or incorrect lifetimes.&lt;/p&gt;

&lt;p&gt;It is only a simple alternative to registering each service manually, in code, recompiling the entire application evey time you needed to swap some services.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction to ASP .NET Core MVC API</title>
      <link>https://radu-matei.com/blog/aspnet-core-api/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-api/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-mvc-services-to-our-application&#34;&gt;Adding the MVC services to our application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#adding-the-post-class&#34;&gt;Adding the &lt;code&gt;Post&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-ipostrepository-interface&#34;&gt;Creating an &lt;code&gt;IPostRepository&lt;/code&gt; interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-in-memory-implementation-of-ipostrepository&#34;&gt;Creating an in-memory implementation of &lt;code&gt;IPostRepository&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-postcontroller-class&#34;&gt;The &lt;code&gt;PostController&lt;/code&gt; class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#registering-the-repository-service-in-startup&#34;&gt;Registering the repository service in &lt;code&gt;Startup&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#startup-cs&#34;&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#testing-the-application&#34;&gt;Testing the application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Up to this point, we have been learning about &lt;a href=&#34;https://radu-matei.github.io/blog/dot-net-core-introduction/&#34;&gt;.NET Core&lt;/a&gt; and &lt;a href=&#34;https://radu-matei.github.io/blog/dot-net-core-getting-started/&#34;&gt;VS Code&lt;/a&gt;, about &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-getting-started/&#34;&gt;ASP .NET Core&lt;/a&gt;, the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;&lt;code&gt;Startup&lt;/code&gt; class&lt;/a&gt;, &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;Routing&lt;/a&gt; and &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-configuration-greeting/&#34;&gt;how to use JSON Configuration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will be looking at ASP .NET Core MVC, more specifically at how to build an API that can be consumed from any type of application, be it web, mobile or desktop.&lt;/p&gt;

&lt;p&gt;We will build a very simple application that will enable the creation of posts (much like messages) and that will take us through adding the MVC services, creating models, controllers and consuming some data.&lt;/p&gt;

&lt;p&gt;We will start this article by building on the code form the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;Startup class&lt;/a&gt; tutorial.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-mvc-services-to-our-application&#34;&gt;Adding the MVC services to our application&lt;/h2&gt;

&lt;p&gt;The first thing we have to do is add the &lt;code&gt;&amp;quot;Microsoft.AspNetCore.Mvc&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; dependency in &lt;code&gt;project.json&lt;/code&gt;, then add the &lt;code&gt;ConfigureServices&lt;/code&gt; method in the &lt;code&gt;Startup&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have to register some routes for the incoming requests, in this case, any incoming requests that match &lt;code&gt;/api/{controller}/{action}/{id?}&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;{controller}&lt;/code&gt; - the name of the controller (for example, &lt;code&gt;TestController&lt;/code&gt; - &lt;code&gt;/api/test&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{action}&lt;/code&gt; - the name of the method from the controller&lt;/p&gt;

&lt;p&gt;&lt;code&gt;{id?}&lt;/code&gt; - optional parameter passed to the method&lt;/p&gt;

&lt;p&gt;So a request for &lt;code&gt;/api/test/hello/3&lt;/code&gt; will be mapped to &lt;code&gt;TestController&lt;/code&gt; in the &lt;code&gt;Hello&lt;/code&gt; method which will have 3 as parameter for &lt;code&gt;id&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        app.UseMvc(routes =&amp;gt;
        {
            routes.MapRoute(
                name: &amp;quot;default&amp;quot;,
                template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can customize your route template in any way, I chose the &lt;code&gt;/api&lt;/code&gt; option because in previous versions of ASP .NET (Web Api) this was the default route for creating an API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point, we can add a controller and make some requests to test our framework. So let&amp;rsquo;s add a controller, I will call it &lt;code&gt;PostsController&lt;/code&gt; and it will have a very simple method that will return a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Mvc;

public class PostsController : Controller
{
	public string Hello()
	{
		return &amp;quot;Hello from MVC!&amp;quot;;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the application, execute &lt;code&gt;dotnet restore&lt;/code&gt; and &lt;code&gt;dotnet run&lt;/code&gt; in the root of the project and browse to &lt;code&gt;http://localhost:5000/api/Posts/Hello&lt;/code&gt;. If everyting works, you should see the message received from the controller.&lt;/p&gt;

&lt;h2 id=&#34;adding-the-post-class&#34;&gt;Adding the &lt;code&gt;Post&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;As we said earlier, each user that enters can publish a post containing his user name and a text, so our &lt;code&gt;Post&lt;/code&gt; class only contains two properties for the &lt;code&gt;UserName&lt;/code&gt; and &lt;code&gt;Text&lt;/code&gt; of the post and an &lt;code&gt;Id&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public class Post
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public string Text { get; set; }

        public Post(int id, string userName, string text)
        {
            Id = id;
            UserName = userName;
            Text = text;
        }

        public Post()
        {
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is also a parameterless constructor and a constructor that takes arguments the three properties.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you add a constructor in a C# class, the compiler will no longer create the default parameterless constructor, and JSON serialization needs a parameterless constructor when serializing and deserializing objects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;creating-an-ipostrepository-interface&#34;&gt;Creating an &lt;code&gt;IPostRepository&lt;/code&gt; interface&lt;/h2&gt;

&lt;p&gt;In order for our API to work, we are going to need a way for it to store data. Regardless of where that data is going to be stored, there should be a consistent way of reading and writing, and we will achieve this through an interface, &lt;code&gt;IPostRepository&lt;/code&gt;, that will expose the minimum necessary methods: a method to read all posts, a method to add a post and a method to retrieve a post with a specified id.&lt;/p&gt;

&lt;p&gt;So the interface should look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;

public interface IPostRepository
{
    List&amp;lt;Post&amp;gt; GetAll();
    Post GetPost(int id);
    void AddPost(Post post);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since this is a very simple example, we are going to store the data in a list in memory, but regardless of the location, the publicly available methods will be exactly the same, making any modifications to the data store easy to implement (more on this later).&lt;/p&gt;

&lt;h2 id=&#34;creating-an-in-memory-implementation-of-ipostrepository&#34;&gt;Creating an in-memory implementation of &lt;code&gt;IPostRepository&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;We will implement the &lt;code&gt;IPostRepository&lt;/code&gt; interface through an in-memory class we will call &lt;code&gt;PostRepository&lt;/code&gt; that will hold the data in a list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we have the three methods to access the data, there is no need to expose the post list outside the class, so it will be private. Besides the list, we only need to implement the three methods from the interface, so here is the full &lt;code&gt;PostRepository&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using System.Linq;

public class PostRepository : IPostRepository
{
    private List&amp;lt;Post&amp;gt; _posts = new List&amp;lt;Post&amp;gt;()
    {
        new Post(1, &amp;quot;Obi-Wan Kenobi&amp;quot;,&amp;quot;These are not the droids you&#39;re looking for&amp;quot;),
        new Post(2, &amp;quot;Darth Vader&amp;quot;,&amp;quot;I find your lack of faith disturbing&amp;quot;)
    };
    public void AddPost(Post post)
    {
        _posts.Add(post);
    }

    public List&amp;lt;Post&amp;gt; GetAll()
    {
        return _posts;
    }

    public Post GetPost(int id)
    {
        return _posts.FirstOrDefault(p =&amp;gt; p.Id == id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-postcontroller-class&#34;&gt;The &lt;code&gt;PostController&lt;/code&gt; class&lt;/h2&gt;

&lt;p&gt;ASP .NET (MVC Core and other versions) maps requests to classes called controllers that are responsible for processing incoming requests, handling user input and generating the response (by themselves or by calling other services).&lt;/p&gt;

&lt;p&gt;We will create a very simple &lt;code&gt;PostController&lt;/code&gt;  that will have methods to get all posts, add a post and retrieve a single post based on the id.&lt;/p&gt;

&lt;p&gt;The controller will have some instance of &lt;code&gt;IPostRepository&lt;/code&gt;(we will see shortly how it will have it) and will call methods from the repository.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;

public class PostsController : Controller
{
    private IPostRepository _postRepository { get; set; }

    public PostsController(IPostRepository postRepository)
    {
        _postRepository = postRepository;
    }

    public List&amp;lt;Post&amp;gt; GetPosts()
    {
        return _postRepository.GetAll();
    }

    public Post GetPost(int id)
    {
        return _postRepository.GetPost(id);
    }

    public void AddPost([FromBody]Post post)
    {
        _postRepository.AddPost(post);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Notice how the &lt;code&gt;AddPost&lt;/code&gt; method accepts a &lt;code&gt;Post&lt;/code&gt; parameter. Because it has the &lt;code&gt;FromBody&lt;/code&gt; attribute, the framework will automatically try to map the body of the request to an object of type &lt;code&gt;Post&lt;/code&gt; that is deserialized from JSON.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Besides from the publicly exposed methods of the API (any public method placed in a controller is publicly accessible from the web), we also have a constructor through which we can provide the appropriate implementation of &lt;code&gt;IPostRepository&lt;/code&gt; and we will specify this in the &lt;code&gt;Startup&lt;/code&gt; of our application.&lt;/p&gt;

&lt;h2 id=&#34;registering-the-repository-service-in-startup&#34;&gt;Registering the repository service in &lt;code&gt;Startup&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;So far, we have created an &lt;code&gt;IPostRepostitory&lt;/code&gt; interface, implemented it in &lt;code&gt;PostRepository&lt;/code&gt; and used it in &lt;code&gt;PostController&lt;/code&gt;(without creating any instance). So if we ran the application right now and navigated to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt; we would get a null reference exception simply because we haven&amp;rsquo;t specified what instance of &lt;code&gt;IPostRepository&lt;/code&gt; our application is supposed to use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We only need to specify that whenever someone needs an &lt;code&gt;IPostRepository&lt;/code&gt;, the framework should provide them (the same) instance of &lt;code&gt;PostRepository&lt;/code&gt;. So when the &lt;code&gt;PostController&lt;/code&gt; constructor has a parameter of type &lt;code&gt;IPostRepository&lt;/code&gt;, the framework will provide an instance of &lt;code&gt;PostRepository&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We added the repository as singleton because of the in-memory impementation: if we made a new instance of &lt;code&gt;PostRepository&lt;/code&gt; for every request, then the post list would be instantiated every time, not saving the modifications.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;startup-cs&#34;&gt;&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddSingleton&amp;lt;IPostRepository, PostRepository&amp;gt;();
    }

    public void Configure(IApplicationBuilder app)
    {
        app.UseMvc(routes =&amp;gt;
        {
            routes.MapRoute(
                name: &amp;quot;default&amp;quot;,
                template: &amp;quot;api/{controller}/{action}/{id?}&amp;quot;
            );
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;testing-the-application&#34;&gt;Testing the application&lt;/h2&gt;

&lt;p&gt;At this point, we can either execute &lt;code&gt;dotnet run&lt;/code&gt; in the root of our project or press &lt;code&gt;F5&lt;/code&gt; in Visual Studio Code.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will use &lt;a href=&#34;https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop&#34;&gt;PostMan for Google Chrome&lt;/a&gt; in order to test the functionality of our API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If we open PostMan and create a GET request to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt;, we will see the two posts that we used to populate the list in &lt;code&gt;PostRepository&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-api/aspnet-core-api-postman-get.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that the response was JSON and it returned a 200 OK HTML code.&lt;/p&gt;

&lt;p&gt;In order to test the post functionality, we create a POST request to &lt;code&gt;http://localhost:5000/api/Posts/AddPost&lt;/code&gt; with a JSON object containing the properties of a &lt;code&gt;Post&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;Id&amp;quot;: 3,
    &amp;quot;UserName&amp;quot;: &amp;quot;Darth Vader&amp;quot;,
    &amp;quot;Text&amp;quot;: &amp;quot;Luke, I am your father!r&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;You can either use the upper camel case or the lower camel case notation (as you saw in the response from the server, the objects were in lower camel case), but the name and type of the properties must match the ones on the server:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;  {
    &amp;quot;id&amp;quot;: 3,
    &amp;quot;userName&amp;quot;: &amp;quot;Darth Vader&amp;quot;,
    &amp;quot;text&amp;quot;: &amp;quot;Luke, I am your father!r&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-api/aspnet-core-api-postman-post.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, if we create another request to &lt;code&gt;http://localhost:5000/api/Posts/GetPosts&lt;/code&gt; we can see that the post we added was saved.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/aspnet-core-api/aspnet-core-api-postman-get-posts.JPG&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;So far we created an API that adds and reads posts from an in-memory data store. A real-life application would have a different type of data store (SQL/NoSQL database) and most certainly an application that consumes this data rather than using it from PostMan.&lt;/p&gt;

&lt;p&gt;This API can be consumed from a web application (HTML + JavaScript), a mobile application (virtually any type of mobile application, regardless of the OS), a desktop application (again, any type of desktop application for any OS), even console applications.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ASP .NET Core JSON Configuration and Dependency Injection</title>
      <link>https://radu-matei.com/blog/aspnet-core-configuration-greeting/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-configuration-greeting/</guid>
      <description>

&lt;h2 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-the-asp-net-core-json-configuration-provider&#34;&gt;Using the ASP .NET Core JSON Configuration Provider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building-the-configurable-greeting-service&#34;&gt;Building the configurable Greeting service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#making-use-of-asp-net-core-dependency-injection&#34;&gt;Making use of ASP .NET Core Dependency Injection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the previous versions of ASP .NET, any configuration setting or parameter you needed was added in &lt;code&gt;web.config&lt;/code&gt; &lt;a href=&#34;http://www.codeproject.com/Articles/301726/Web-config-File-ASP-NET&#34;&gt;(complete description of the old &lt;code&gt;web.config&lt;/code&gt; file)&lt;/a&gt;, or added in a separate XML file and referenced in &lt;code&gt;web.config&lt;/code&gt; (for scenarios like database connection strings, or storing APIs access tokens).&lt;/p&gt;

&lt;p&gt;The new configuration system provides support for JSON, XML, INI and for in-memory configuration, while also allowing you to &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html#custom-config-providers&#34;&gt;create your custom configuration provider&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a detailed view of ASP .NET Core Configuration system, read the &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html&#34;&gt;Official ASP .NET Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;In the tutorial about Routing&lt;/a&gt;, we created a very simple web application that used the Routing service to respond to some requests, but they were hardcoded and if we wanted to change the response message, we would have had to recompile the entire application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For more information about Routing, check the &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;ASP .NET Core Routing Tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s assume that in our application we want the response messages not to be hardcoded in &lt;code&gt;Startup&lt;/code&gt; anymore, but stored in a configuration file so we don&amp;rsquo;t have to stop, modify or recompile our application every time the messages or the routes change.&lt;/p&gt;

&lt;p&gt;More clearly, we want to map the keys from the JSON file below as routes and the values as the responses we want our application to give, so when a user browses in our application to &lt;code&gt;/some-route&lt;/code&gt;, if &lt;code&gt;some-route&lt;/code&gt; is present in the JSON configuration file, then the response will be the value from the file, if else to display a default message.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hi&amp;quot;: &amp;quot;Hi!&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;Hello!&amp;quot;,
    &amp;quot;bye&amp;quot;: &amp;quot;Goodbye!&amp;quot;,
    &amp;quot;default&amp;quot;: &amp;quot;This is default!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, if we modify the configuration file while the application is running, our application should be able to use the latest configuration. (As we will see, we will not have much to do here since this is built into ASP .NET).&lt;/p&gt;

&lt;p&gt;There can be any number of defined paths in our configuration file and they can change with any frequency (so that hard-coding them in our application is not an option).&lt;/p&gt;

&lt;h2 id=&#34;using-the-asp-net-core-json-configuration-provider&#34;&gt;Using the ASP .NET Core JSON Configuration Provider&lt;/h2&gt;

&lt;p&gt;As we said earlier, the new ASP .NET implements a JSON configuration provider that allows us to read and use configurations from JSON files (and not only), and we can have strong typing (where we define classes for our configuration settings) or we can access them using directly their key.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For a complete article on creating &lt;a href=&#34;https://weblog.west-wind.com/posts/2016/May/23/Strongly-Typed-Configuration-Settings-in-ASPNET-Core&#34;&gt;Strongly Typed Configuration Settings in ASP .NET Core, see this article by Rick Strahl&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To use configuration settings in ASP .NET Core, simply instantiate a &lt;code&gt;Configuration&lt;/code&gt; object (using a &lt;code&gt;ConfigurationBuilder&lt;/code&gt;)  and indicate the source of the JSON file. Then, we can add multiple sources and types of sources that populate our application&amp;rsquo;s configuration.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At its simplest, &lt;code&gt;Configuration&lt;/code&gt; is just a collection of sources, which provide the ability to read and write name/value pairs. If a name/value pair is written to &lt;code&gt;Configuration&lt;/code&gt;, it is not persisted. This means that the written value will be lost when the sources are read again.&lt;/p&gt;

&lt;p&gt;Developers are not limited to using a single configuration source. In fact several may be set up together such that a default configuration is overridden by settings from another source if they are present.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/configuration.html#using-the-built-in-sources&#34;&gt;The Official ASP .NET Core Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Because at the time when we write the application we can&amp;rsquo;t know the exact paths, we will not create stronyly-typed configurations but we will take the path from our application an check to see wether that path exists in our configuration file.&lt;/p&gt;

&lt;h2 id=&#34;building-the-configurable-greeting-service&#34;&gt;Building the configurable Greeting service&lt;/h2&gt;

&lt;p&gt;First of all, &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-startup/&#34;&gt;follow all the steps in order to create an ASP .NET Core application with a &lt;code&gt;Startup&lt;/code&gt; class from this tutorial&lt;/a&gt;, that means:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create new app using &lt;code&gt;dotnet new&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add the &lt;code&gt;&amp;quot;Microsoft.AspNetCore.Server.Kestrel&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; NuGet package&lt;/li&gt;
&lt;li&gt;add an empty &lt;code&gt;Startup&lt;/code&gt; class&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then, we create a new file, &lt;code&gt;greetings.json&lt;/code&gt; in the same folder as our &lt;code&gt;Program.cs&lt;/code&gt;, &lt;code&gt;Startup.cs&lt;/code&gt; and &lt;code&gt;project.json&lt;/code&gt; files, where we add our custom routes and messages we want our application to respond with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;hi&amp;quot;: &amp;quot;Hi!&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;Hello!&amp;quot;,
    &amp;quot;bye&amp;quot;: &amp;quot;Goodbye!&amp;quot;,
    &amp;quot;default&amp;quot;: &amp;quot;This is default!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to add another NuGet package, &lt;code&gt;&amp;quot;Microsoft.Extensions.Configuration.Json&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; that will contain the necessary methods for using JSON files as configuration.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;Startup&lt;/code&gt; we create a property of type &lt;code&gt;IConfiguration&lt;/code&gt; where we will keep our configuration files: &lt;code&gt;public IConfiguration Configuration {get;set;}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, we add a constructor for the &lt;code&gt;Startup&lt;/code&gt; class that will instantiate a &lt;code&gt;ConfigurationBuilder&lt;/code&gt; that will actually get the configuration information in our &lt;code&gt;Configuration&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public Startup(IHostingEnvironment env)
    {
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&amp;quot;greetings.json&amp;quot;, optional: false, reloadOnChange: true);
        
        Configuration = configurationBuilder.Build();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The constructor has an &lt;code&gt;IHostingEnvironment&lt;/code&gt; parameter that is used to establish the directory of the JSON configuration file. Since we placed it in the same folder as the other files, we can simply get the current directory: &lt;code&gt;Directory.GetCurrentDirectory()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After we instantiate the &lt;code&gt;ConfigurationBuilder&lt;/code&gt; we chain two method calls - one for establishing the directory of the configuration file, the other for determing the actual name of the file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.AddJsonFile()&lt;/code&gt; method takes three arguments in this case:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the name of the file - in our case &lt;code&gt;greetings.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;bool&lt;/code&gt; that determines wether this configuration file is optional or not, used to determine the order in which the system searches the files (if there are multiple files) if the same configuration name exists in multiple files.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;bool&lt;/code&gt; that specifies what happens if the configuration file is modified while the application is running - &lt;code&gt;reloadOnChange&lt;/code&gt;
After this, we set our &lt;code&gt;Configuration&lt;/code&gt; property to what the &lt;code&gt;configurationBuilder&lt;/code&gt; &amp;ldquo;builds&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is to add the &amp;ldquo;&lt;code&gt;Microsoft.AspNetCore.Routing&amp;quot;: &amp;quot;1.0.0&amp;quot;&lt;/code&gt; package in &lt;code&gt;project.json&lt;/code&gt;, create the &lt;code&gt;Configure&lt;/code&gt; method in &lt;code&gt;Startup&lt;/code&gt; and add the routing service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;As you write code in Visual Studio or Visual Studio Code, you can press Ctrl + . (period) to show suggestions for errors (like adding &lt;code&gt;using&lt;/code&gt; statements for you).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, we create the &lt;code&gt;Configure&lt;/code&gt; method where we will hook up incoming requests and map them with the routes from our configuration file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            var response = (routeMessage != null) ? routeMessage : defaultMessage;

            return context.Response.WriteAsync(response);
        });

        app.UseRouter(routeBuilder.Build());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We create a new &lt;code&gt;RouteBuilder&lt;/code&gt; and map a new GET &lt;code&gt;route&lt;/code&gt; in &lt;a href=&#34;https://radu-matei.github.io/blog/aspnet-core-routing/&#34;&gt;the same way as in this article&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We know that our configuration is now accessible through the &lt;code&gt;Configuration&lt;/code&gt; property that we populated in the &lt;code&gt;Startup&lt;/code&gt; constructor, and the configuration settings are an &lt;code&gt;IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;&lt;/code&gt;, that is a collection of key-value pairs of strings, so we can use Linq to search for the key-value pair in our file that has the same key as our path and take the value from that pair.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For some examples of using Linq with lambdas &lt;a href=&#34;http://www.codemag.com/article/1001051&#34;&gt;check this article from Code Magazine&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also search for the default message in our JSON so that if the path does not exist in the file, we have a standard respone.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, depending on wether the route actually exists in our configuration file or not, we return either the message of that specific route, or the default message.&lt;/p&gt;

&lt;p&gt;This is the full &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;
using System.Linq;

public class Startup
{
    public IConfiguration Configuration {get;set;}
    public Startup(IHostingEnvironment env)
    {
        var configurationBuilder = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile(&amp;quot;greetings.json&amp;quot;, optional: false, reloadOnChange: true);
        
        Configuration = configurationBuilder.Build();
    }
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();
    }
    public void Configure(IApplicationBuilder app)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == context.GetRouteValue(&amp;quot;route&amp;quot;)
                .ToString())
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            var response = (routeMessage != null) ? routeMessage : defaultMessage;

            return context.Response.WriteAsync(response);
        });

        app.UseRouter(routeBuilder.Build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the application and open a browser, we can check if our routing works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:5000/hello - This should display Hello!
http://localhost:5000/hi - This should display Hi!
http://localhost:5000/bye - This should display Goodbye!
http://localhost:5000/default or http://localhost:5000/anything-else - This should display This is default!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Without closing the application, go to &lt;code&gt;greeting.json&lt;/code&gt; and either add a new key-value pair, or modify an existing one&amp;rsquo;s value, save the file and navigate to that path.&lt;/p&gt;

&lt;p&gt;Normally, you should see that our application was able to load the configuration file without restarting or recompiling.&lt;/p&gt;

&lt;h2 id=&#34;making-use-of-asp-net-core-dependency-injection&#34;&gt;Making use of ASP .NET Core Dependency Injection&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;So far, the examples we&amp;rsquo;ve had were pretty easy to understand, straightforward and olny relied on information that built upon the previous articles.
This example will be about dependency injection, something we haven&amp;rsquo;t discussed yet and will not be an introductory tutorial,  which will be a topic for a future article.&lt;/p&gt;

&lt;p&gt;The reason for doing this is to show how to build a still very simple application, but one that is a lot more configurable.&lt;/p&gt;

&lt;p&gt;Martin Fowler has written an extensive article on &lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34;&gt;Inversion of Control Containers and the Dependency Injection Pattern&lt;/a&gt;. Microsoft Patterns and Practices also has a great description of &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dn178469(v=pandp.30).aspx&#34;&gt;Dependency Injection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For a more detailed view of dependency injection in ASP .NET Core applications, &lt;a href=&#34;https://docs.asp.net/en/latest/fundamentals/dependency-injection.html&#34;&gt;read the article from the Official ASP .NET Core Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our application works, but there is a lot of logic code in &lt;code&gt;Startup&lt;/code&gt;, a place for configuration.&lt;/p&gt;

&lt;p&gt;We will try to extract the part of &lt;code&gt;Startup&lt;/code&gt; that deals with actually getting the response from the &lt;code&gt;JSON&lt;/code&gt; file in a separate class and learn how to inject that service in various places (like other services, controllers or even in &lt;code&gt;Startup&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;First of all, let&amp;rsquo;s think at what public methods and properties should a greeting service should have. Basically, it should only have a single method that receives the path a user navigated to and should return a string, the response taken from the JSON file.&lt;/p&gt;

&lt;p&gt;In order to make dependency injection work, we will make use of interfaces. Meaning we will build an interface for the greeting service, &lt;code&gt;IGreetingService&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;To see an example with interfaces, &lt;a href=&#34;https://github.com/microsoft-dx/csharp-fundamentals/tree/master/CSharpFundamentals/csharp09%20-%20Interfaces&#34;&gt;check this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file, &lt;code&gt;IGreetingService.cs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface IGreetingService
{
    string Greet(string route);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, in another file, &lt;code&gt;GreetingService.cs&lt;/code&gt; we will add the actual implementation of the service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.Linq;
using Microsoft.Extensions.Configuration;

public class GreeringService : IGreetingService
{
    private IConfiguration Configuration {get;set;}

    public GreeringService(IConfiguration configuration)
    {
        Configuration = configuration;
    }
    public string Greet(string route)
    {
            var routeMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == route)
                .Value;
            
            var defaultMessage = Configuration.AsEnumerable()
                .FirstOrDefault(r =&amp;gt; r.Key == &amp;quot;default&amp;quot;)
                .Value;

            return (routeMessage != null) ? routeMessage : defaultMessage;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically, this class has the &lt;code&gt;Greet&lt;/code&gt; method which contains most of the logic we had in &lt;code&gt;Startup&lt;/code&gt; for retrieving  the response from the JSON file. It also has an &lt;code&gt;IConfiguration&lt;/code&gt; property, this time injected in the controller (we will see a bit later where and how this is done).&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s take a look at the &lt;code&gt;Startup&lt;/code&gt; class, this time at the &lt;code&gt;Configure&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var route = context.GetRouteValue(&amp;quot;route&amp;quot;).ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new thing here is that we have an &lt;code&gt;IGreetingService&lt;/code&gt; parameter in the method signature that we use when returning the message.&lt;/p&gt;

&lt;p&gt;Both the &lt;code&gt;IGreetingService&lt;/code&gt; and &lt;code&gt;IConfiguration&lt;/code&gt; parameters are configured in the &lt;code&gt;ConfigureServices&lt;/code&gt; method, also from &lt;code&gt;Startup&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider =&amp;gt; new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient&amp;lt;IGreetingService, GreeringService&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First of all we add the routing service (just like in the previous examples).&lt;/p&gt;

&lt;p&gt;The last line of this method states that every time some class requests a parameter of type &lt;code&gt;IGreetingService&lt;/code&gt;, the DI (dependency injection) engine will provide it with a new (every time a new) implementation of &lt;code&gt;GreetingService&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The second method call is the most difficult of all: it says that every time someone requests an &lt;code&gt;IConfiguration&lt;/code&gt; parameter, the engine should provide the same instance (singleton) generated by this chain of method calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                 optional: false, 
                 reloadOnChange: true)
     .Build(), 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the same as earlier.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the complete &lt;code&gt;Startup&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System.IO;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddRouting();

        services.Add(new ServiceDescriptor(typeof(IConfiguration), 
                     provider =&amp;gt; new ConfigurationBuilder()
                                    .SetBasePath(Directory.GetCurrentDirectory())
                                    .AddJsonFile(&amp;quot;greetings.json&amp;quot;, 
                                                 optional: false, 
                                                 reloadOnChange: true)
                                    .Build(), 
                     ServiceLifetime.Singleton));
                     
        services.AddTransient&amp;lt;IGreetingService, GreeringService&amp;gt;();
    }
    public void Configure(IApplicationBuilder app, IGreetingService greetingService)
    {
        var routeBuilder = new RouteBuilder(app);

        routeBuilder.MapGet(&amp;quot;{route}&amp;quot;, context =&amp;gt; 
        {
            var route = context.GetRouteValue(&amp;quot;route&amp;quot;).ToString();
            return context.Response.WriteAsync(greetingService.Greet(route));
        });

        app.UseRouter(routeBuilder.Build());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We created a web application for which we configured the paths and the associated responses in an external JSON file. We ectracted this functionality in a service, &lt;code&gt;GreetingService&lt;/code&gt; that was provided using dependency injection.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>