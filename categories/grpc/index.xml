<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Grpc on Radu Matei&#39;s Blog</title>
    <link>https://radu-matei.com/categories/grpc/</link>
    <description>Recent content in Grpc on Radu Matei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Dec 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://radu-matei.com/categories/grpc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>kube-toolkit: Toolkit for creating gRPC-based CLI tools for Kubernetes, written in Go</title>
      <link>https://radu-matei.com/blog/kube-toolkit/</link>
      <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/kube-toolkit/</guid>
      <description>Table of Contents  Introduction Architecture Vendoring kube-toolkit Defining and using gRPC services Connecting to the Kubernetes cluster Using cobra, folder structure and adding your own commands See in in action Conclusion  Introduction If you ever used Helm or Draft, you know they are very cool command-line tools that connect to a Kubernetes cluster, more specifically to a server-side componend (Tiller in the case of Helm, Draftd for Draft) without exposing ports on the Internet, and allow you to interact with your cluster through gRPC-based services.</description>
    </item>
    
    <item>
      <title>Adding native Go in Azure Functions</title>
      <link>https://radu-matei.com/blog/golang-azure-functions/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/golang-azure-functions/</guid>
      <description>Table of Contents  Introduction  Introduction Fall 2017 came with the announcement of Azure Functions on Linux and Mac and the ability to add the Azure Functions runtime in a container.
Besides that, the runtime has been split between a host (which manages function events) and language worker processes (which runs user functions for a given language). These two pieces communicate using gRPC as a messaging layer. - essentially, this allows you to add support for Azure Functions to any language you want - you only have to create a gRPC implementation in your language of choice and accept incoming requests from the runtime host.</description>
    </item>
    
  </channel>
</rss>