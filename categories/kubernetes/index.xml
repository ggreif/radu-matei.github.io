<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Radu Matei - Developer Evangelist</title>
    <link>https://radu-matei.com/categories/kubernetes/index.xml</link>
    <description>Recent content on Radu Matei - Developer Evangelist</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://radu-matei.com/categories/kubernetes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Jenkins declarative pipelines with Kubernetes </title>
      <link>https://radu-matei.com/blog/kubernetes-jenkins-azure/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/kubernetes-jenkins-azure/</guid>
      <description>

&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of Contents&lt;/h2&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In previous articles &lt;a href=&#34;https://radu-matei.com/blog/k8s18-azure/&#34;&gt;we deployed a Kubernetes 1.8 cluster to Azure using acs-engine&lt;/a&gt;, then &lt;a href=&#34;https://radu-matei.com/blog/k8s-helm-draft-azure/&#34;&gt;configured Helm and Draft to simplify testing applications&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will explore how to deploy Jenkins using Helm and how to configure Jenkins declarative pipelines that build containers, push images to an image repository and update Kubernetes deployments.&lt;/p&gt;

&lt;h1 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;p&gt;To follow along with this article, &lt;em&gt;you need a Kubernetes cluster&lt;/em&gt; (we will use Kubernetes v1.8.0, but the instructions were also tested with v1.7.0) with Helm installed and a terminal with &lt;code&gt;kubectl&lt;/code&gt; and &lt;code&gt;helm&lt;/code&gt; installed and configured.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://radu-matei.com/blog/k8s-helm-draft-azure&#34;&gt;This article picks up where the last one ended, so you will need a Kubernetes cluster with &lt;code&gt;helm&lt;/code&gt; installed. Here you can find very simple instructions on how to achieve it.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;My cluster is deployed into Azure, West Europe, but you can do the exact same steps using the Google Container Engine or your on-prem cluster (note that you will not be given public IP addresses as is the case with Azure or GKE).&lt;/p&gt;

&lt;p&gt;Now to check that everything is configured, verify your cluster information and vesions. This is my starting point:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/cluster-info.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-jenkins-with-helm&#34;&gt;Deploying Jenkins with Helm&lt;/h1&gt;

&lt;p&gt;Using Helm you can easily deploy well-know applications (like Hadoop, Grafana, MongoDB, Redis) easily on your Kubernetes cluster using charts.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Charts are curated application definitions for Kubernetes Helm.&lt;/p&gt;

&lt;p&gt;More information on &lt;a href=&#34;https://github.com/kubernetes/helm&#34;&gt;Helm&lt;/a&gt; and &lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;charts&lt;/a&gt; on GitHub&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If we search for &lt;a href=&#34;https://github.com/kubernetes/charts/tree/master/stable/jenkins&#34;&gt;Jenkins in the list of stable charts&lt;/a&gt;, we find very clear instructions on how to deploy it.&lt;/p&gt;

&lt;p&gt;A chart is composed of some templates (Kubernetes deployment files) and a file that holds our specific values for Jenkins - Docker image for master and agents, plugins to install, persistent volumes - basically all configurable values we can get for our Jenkins deployment.&lt;/p&gt;

&lt;p&gt;This is the only file we will need to edit ourselves. Below you can find the one I use.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/466ae82b4b269d6bb762b088683bf9e6.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/charts/tree/master/stable/jenkins&#34;&gt;Here you can find all possible configuration for the values file, adjust it to your specific needs&lt;/a&gt;!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that this verison mounts the &lt;code&gt;/var/run/docker.sock&lt;/code&gt; socket inside the agent pods so we can built Docker images on our agents. There is a debate on wether you want to actually do that (basically you expose the Docker engine of the Kubernetes agent the pod is running inside), so do it at your own risk.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This also installs other plugins - such as Jenkins Blue Ocean.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/charts/blob/master/stable/jenkins/values.yaml&#34;&gt;The default values for Jenkins (that you can find in this repo)&lt;/a&gt; does not expose it, you can use that, but note that some features we will use later (basically &lt;code&gt;docker build&lt;/code&gt; inside the worker pod) will not work.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Get this file locally, then execute:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;helm install --name jenkins -f jenkins-values.yaml stable/jenkins&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;After you deploy the chart, you will get instructions on how to get the initial admin password:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/instructions.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that the initial admin username is &lt;code&gt;admin&lt;/code&gt; and you should probably change it :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If you take a look at the state of your cluster, you can see that &lt;code&gt;helm&lt;/code&gt; deployed &lt;code&gt;jenkins&lt;/code&gt;, which resulted in two services in Kubernetes, one for the master and one for the agents.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/deployed.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Using the initial admin password (follow the instructions you had as output from Helm after deploying Jenkins), go to the public IP of your service and login.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can find the command I used to get the initial admin password, but note that it will vary in your case based on the name you provided and the namespace where you deployed Jenkins.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;printf $(kubectl get secret --namespace default jenkins-jenkins -o jsonpath=&amp;quot;{.data.jenkins-admin-password}&amp;quot; | base64 --decode);echo&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you have deployed an instance of Jenkins on your Kubernetes cluster using Helm, already configured with all plugins you specified in your &lt;code&gt;jenkins-values.yaml&lt;/code&gt; file and with the ability to execute builds on your cluster.&lt;/p&gt;

&lt;h1 id=&#34;create-credentials-for-your-image-repository&#34;&gt;Create credentials for your image repository&lt;/h1&gt;

&lt;p&gt;The goal is to have end to end automatic deployment to our Kubernetes cluster. This means we need to push images to an image repository (like Docker Hub, Azure Container Repository, Google Container Repository) as part of our Jenkins build.&lt;/p&gt;

&lt;p&gt;Since all the repositories need some sort of authentication, we need to create a credential binding in Jenkins so that we don&amp;rsquo;t keep credentials in source control&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Never, ever keep credentials in source control. Or connection strings, or any sort of sensitive information!&lt;/p&gt;

&lt;p&gt;We can keep them as Kuberentes secrets, or as Jenkins secrets. In this case we will use Jenkins secrets, and we will reference them in our Jenkinsfile.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now create new credentials in Jenkins:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Click the &lt;strong&gt;Credentials&lt;/strong&gt; link in the sidebar&lt;/p&gt;

&lt;p&gt;Click on the &lt;strong&gt;Global credentials&lt;/strong&gt; domain&lt;/p&gt;

&lt;p&gt;Click [&lt;strong&gt;Add Credential&lt;/strong&gt;]&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://support.cloudbees.com/hc/en-us/articles/203802500-Injecting-Secrets-into-Jenkins-Build-Jobs&#34;&gt;Full Cloudbees article that explains credentials and credential bindings in Jenkins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/credentials.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now that you have the credentials in place (don&amp;rsquo;t forget to also add an intuitive ID for your credentials in the place I left blank!), you can create a new pipeline.&lt;/p&gt;

&lt;h1 id=&#34;the-jenkinsfile&#34;&gt;The Jenkinsfile&lt;/h1&gt;

&lt;p&gt;The initial goal was to create declarative Jenkins pipelines that we can later store in source control. This pipeline describes our build process, and a usual process when we work with Kubernetes is to build a Docker image, push it to a image repository then to some work with &lt;code&gt;kubectl&lt;/code&gt; (like update the image for a deployment), or with &lt;code&gt;helm&lt;/code&gt; (update a chart, or deploy a new one).&lt;/p&gt;

&lt;p&gt;We will now look at how to write the simplest Jenkinsfile that will to exactly that: build and push an image to a repo and do work with &lt;code&gt;kubectl&lt;/code&gt; and &lt;code&gt;helm&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/jenkinsci/kubernetes-plugin&#34;&gt;Here you can read all about writing Jenkinsfiles with the Kubernetes plugin for Jenkins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/376f5a2b042b0df82d7d905c9c6cf8ff.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t forget to use your credential ID in the Jenkinsfile!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This Jenkinsfile makes use of having multiple containers in the same Kubernetes pod - we will have 3 containers - one based on a Docker image, one based on &lt;code&gt;kubectl&lt;/code&gt; and the last based on &lt;code&gt;helm&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can create your own containers - in this case I used the official one for Docker and the images built by &lt;a href=&#34;https://twitter.com/LachlanEvenson&#34;&gt;Lachlan Evenson&lt;/a&gt;, since are widely used on Docker Hub and I kind of trust Lachlan :)&lt;/p&gt;

&lt;p&gt;Use images from the Internet at your own risk!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Note that we are mounting the Docker socket inside our pod so the Docker container has access to the Docker engine - this step is debatable for using in production (but it is arguably better than using Docker-in-Docker - &lt;a href=&#34;https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/&#34;&gt;read this article&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Since we are already running in the cluster, the other two containers are already authenticated.&lt;/p&gt;

&lt;p&gt;You can test this Jenkinsfile by creating a simple Jenkins pipeline and pasting this Jenkinsfile directly there (ugly, but the easiest way to do it).&lt;/p&gt;

&lt;p&gt;This is part of the output for the Jenkinsfile above. Please note that from within this container you have access to the real cluster!
You might want to take a look at the new 1.8 RBAC features in Kubernetes, but keep in mind that &lt;em&gt;with great power comes great responsibility!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/real-cluster.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;using-the-jenkinsfile&#34;&gt;Using the Jenkinsfile&lt;/h1&gt;

&lt;p&gt;Basically, now all you need to do is replace the dummy steps I wrote for each step and you have yourself a fully functional Jenkins pipeline!&lt;/p&gt;

&lt;p&gt;Put it side by side with your code in the repository and take care of it just as you would with your source code!&lt;/p&gt;

&lt;h1 id=&#34;investigating-what-actually-happens-in-the-cluster&#34;&gt;Investigating what actually happens in the cluster&lt;/h1&gt;

&lt;p&gt;We see that the steps in our Jenkinsfile are executed, but let&amp;rsquo;s explore a bit where that really happens.&lt;/p&gt;

&lt;p&gt;Whenever there&amp;rsquo;s a new build, the master will dynamically create agent pods based on your Jenkinsfile. There will always be a &lt;code&gt;jnlp&lt;/code&gt; container there that knows how to connect to the master, among with whatever containers you specify.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see that pod in action:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/pod.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here you can see all containers inside the pod (with their image, tag and environment variables).&lt;/p&gt;

&lt;p&gt;The cool thing about this plugin is you only see resources being used (CPU + memory) when there&amp;rsquo;s a build in progress. Once that build is done, your resources are freed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/kubernetes-jenkins-azure/spike.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The short spike at the end corresponds to a build being executed&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We deployed Jenkins on our Kubernetes cluster using Helm (in a reproduceable way, you can deploy it again with the same plugins at any time - keep this in a source control as well), then saw how to configure credentials and write Jenkinsfiles in a declarative way and have multiple containers in the agent pod.&lt;/p&gt;

&lt;h1 id=&#34;feedback&#34;&gt;Feedback&lt;/h1&gt;

&lt;p&gt;If you have a better aproach at any of the concepts presented in this article, or have any questions, please use the comments below.&lt;/p&gt;

&lt;p&gt;As always, thanks for reading, and any feedback is highly appreciated :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Get started with Helm and Draft for Kubernetes</title>
      <link>https://radu-matei.com/blog/k8s-helm-draft-azure/</link>
      <pubDate>Sat, 07 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s-helm-draft-azure/</guid>
      <description>

&lt;h1 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-kubectl-helm-and-draft&#34;&gt;Using kubectl, helm and draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#configure-helm&#34;&gt;Configure Helm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#configure-draft&#34;&gt;Configure Draft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#creating-an-application&#34;&gt;Creating an application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#investigating-what-actually-happens&#34;&gt;Investigating what actually happens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exiting-the-container&#34;&gt;Exiting the container&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#feedback&#34;&gt;Feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.com/blog/k8s18-azure/&#34;&gt;In the previous tutorial&lt;/a&gt; I used Azure to provision the infrastructure required to run a Kubernetes cluster. If you don&amp;rsquo;t have an Azure subscription you can &lt;a href=&#34;https://azure.microsoft.com/en-us/free/?v=17.39a&#34;&gt;create a free account and get $200 for 12 months&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I deployed 4 D2_V2 VMs (1 master + 3 agents) with Linux and will cost approximately $13 - $14 / day, but you can change the type of the VM to be D1_V2 in the cluster definition, and the cost will go down to $6 / day.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that the pricing will vary slightly based on the location where you deploy the VMs.&lt;/p&gt;

&lt;p&gt;Cost estimation created using the &lt;a href=&#34;https://azure.microsoft.com/en-us/pricing/calculator/&#34;&gt;Azure Pricing Calculator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/pricing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://radu-matei.com/blog/k8s18-azure/&#34;&gt;In the previous post we saw how to deploy a Kubernetes 1.8 cluster on Azure using &lt;code&gt;acs-engine&lt;/code&gt; and the Azure Cloud Shell&lt;/a&gt;. Now we will use that cluster to get started with Helm and Draft to simplify our development process.&lt;/p&gt;

&lt;p&gt;In the next post we will see how to integrate Jenkins with Azure Contaier Instances in this process, so stay tuned :)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you don&amp;rsquo;t have your &lt;code&gt;kubeconfig&lt;/code&gt; and SSH keys to your &lt;a href=&#34;https://radu-matei.com/blog/k8s18-azure/&#34;&gt;cluster and you deployed using the previous article, you might want to download the certificates and config files so you can access the cluster from outside the Azure Cloud Shell, as instructed in the previous article&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;using-kubectl-helm-and-draft&#34;&gt;Using kubectl, helm and draft&lt;/h1&gt;

&lt;p&gt;Normally at this point you would manually download and install the latest version for &lt;code&gt;kubectl&lt;/code&gt;, &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;draft&lt;/code&gt;. Luckily, you can use the Dockerfile below to create yourself an image that already has those installed.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/dba91743ae04784076f31485a5a521a2.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;You can find &lt;a href=&#34;https://github.com/radu-matei/kubectl-helm-draft&#34;&gt;the repository on GitHub here&lt;/a&gt; and &lt;a href=&#34;https://hub.docker.com/r/radumatei/kubectl-helm-draft/&#34;&gt;the image on Docker Hub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please note that at the time of writing this article, the lastest versions are: &lt;code&gt;v1.8.0&lt;/code&gt; for &lt;code&gt;kubectl&lt;/code&gt;, &lt;code&gt;v2.6.2&lt;/code&gt; for &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;v0.7.0&lt;/code&gt; for &lt;code&gt;draft&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When a new version is available, simply change the environment variable in the Dockerfile and build again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One reason for this is that I regularly work with multiple clusters, and all of these commands create their config in the home directory. Not once it happened that I overwrote the config (for &lt;code&gt;kubectl&lt;/code&gt;, &lt;code&gt;helm&lt;/code&gt; or &lt;code&gt;draft&lt;/code&gt;). I really think this is cleaner approach - you have a folder for your cluster with all its config there. Another cluster, simply another folder.&lt;/p&gt;

&lt;p&gt;Then, you use the config from within a container.&lt;/p&gt;

&lt;p&gt;The image simply installs &lt;code&gt;kubectl&lt;/code&gt;, &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;draft&lt;/code&gt; and exposes a port inside the container (so we can easily &lt;code&gt;kubectl proxy&lt;/code&gt; a bit later).&lt;/p&gt;

&lt;p&gt;Now all you need to do is run a conainer based on the image you just built, and mount the cluster access certificates folder so we can point &lt;code&gt;kubectl&lt;/code&gt; at.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/c3a8619208fdaab90ccb1a82785e1731.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/initial-run.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you don&amp;rsquo;t know where those certificates came from, &lt;a href=&#34;https://radu-matei.com/blog/k8s18-azure/&#34;&gt;check out this article&lt;/a&gt; and modify the path to match your own.&lt;/p&gt;

&lt;p&gt;I also mounted a local directory so I can later create an application from outside the container and exposed port 8080 (you can choose another one) to access the dashboard.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Of course, neither &lt;code&gt;helm&lt;/code&gt;, nor &lt;code&gt;draft&lt;/code&gt; will be able to connect to the cluster, as their server-side components (&lt;code&gt;tiller&lt;/code&gt; and &lt;code&gt;draftd&lt;/code&gt;) are not configured yet.&lt;/p&gt;

&lt;p&gt;Now simply point &lt;code&gt;kubectl&lt;/code&gt; to your &lt;code&gt;kubeconfig&lt;/code&gt; file (in my case in the &lt;code&gt;_output&lt;/code&gt; folder from &lt;code&gt;acs-engine&lt;/code&gt;, but can be from anywhere) and you have yourself a container with the latest tools for Kubernetes, connected to a cluster running the latest version of Kubernetes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/export-config.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;configure-helm&#34;&gt;Configure Helm&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Helm is a tool that streamlines installing and managing Kubernetes applications. Think of it like apt/yum/homebrew for Kubernetes.&lt;/p&gt;

&lt;p&gt;Helm has two parts: a client (helm) and a server (tiller)&lt;/p&gt;

&lt;p&gt;Tiller runs inside of your Kubernetes cluster, and manages releases (installations) of your charts.&lt;/p&gt;

&lt;p&gt;Helm runs on your laptop, CI/CD, or wherever you want it to run.&lt;/p&gt;

&lt;p&gt;Charts are Helm packages that contain at least two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A description of the package (Chart.yaml)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One or more templates, which contain Kubernetes manifest files&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Charts can be stored on disk, or fetched from remote chart repositories (like Debian or RedHat packages)&lt;/p&gt;

&lt;p&gt;More on &lt;a href=&#34;https://github.com/kubernetes/helm&#34;&gt;the GitHub repo for Helm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We now need to initialize &lt;code&gt;helm&lt;/code&gt;. Since we are in a container, once we exit all config files written by &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;draft&lt;/code&gt; will be lost. That&amp;rsquo;s why we have the &lt;code&gt;cluster&lt;/code&gt; directory, which is mounted from the host.&lt;/p&gt;

&lt;p&gt;We will now need to point &lt;code&gt;helm&lt;/code&gt; to write its config in &lt;code&gt;/cluster&lt;/code&gt; and run &lt;code&gt;helm init&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export HELM_HOME=/cluster/&lt;/code&gt; and &lt;code&gt;helm init&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/helm-init.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Please note that the default server version of &lt;code&gt;tiller&lt;/code&gt; (the &lt;code&gt;helm&lt;/code&gt; server-side component) is at version &lt;code&gt;v2.6.1&lt;/code&gt;. You can easily upgrade it using &lt;code&gt;helm init --upgrade&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/helm-upgrade.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We now have configured &lt;code&gt;helm&lt;/code&gt;:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/helm-ls-search.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;configure-draft&#34;&gt;Configure Draft&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Draft makes it easy to build applications that run on Kubernetes. Draft targets the &amp;ldquo;inner loop&amp;rdquo; of a developer&amp;rsquo;s workflow: as they hack on code, but before code is committed to version control.&lt;/p&gt;

&lt;p&gt;Using Draft is as simple as:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;draft create&lt;/code&gt; to containerize your application based on Draft packs&lt;/p&gt;

&lt;p&gt;&lt;code&gt;draft up&lt;/code&gt; to deploy your application to a Kubernetes dev sandbox, accessible via a public URL&lt;/p&gt;

&lt;p&gt;Use a local editor to modify the application, with changes deployed to Kubernetes in seconds&lt;/p&gt;

&lt;p&gt;Once the developer is happy with changes made via Draft, they commit and push to version control, after which a continuous integration (CI) system takes over. Draft builds upon Kubernetes Helm and the Kubernetes Chart format, making it easy to construct CI pipelines from Draft-enabled applications.&lt;/p&gt;

&lt;p&gt;More on &lt;a href=&#34;https://github.com/azure/draft&#34;&gt;the GitHub repo for Draft&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we are going to use &lt;a href=&#34;https://github.com/Azure/draft/blob/master/docs/ingress.md&#34;&gt;a very cool feature of Draft called ingress&lt;/a&gt;. Basically, this will allow us to use a base domain - &lt;code&gt;*.draft.yourdomain.com&lt;/code&gt; to expose your apps while testing. Of course, you will need to own a domain and to be able to create a wildcard &lt;code&gt;A Record&lt;/code&gt; pointing back to an nginx controller in your cluster.&lt;/p&gt;

&lt;p&gt;You will use &lt;code&gt;helm&lt;/code&gt; to deploy an nginx ingress controller with a public IP address (if you are on Azure or GKE this will be done automatically for you after a couple of minutes):&lt;/p&gt;

&lt;p&gt;&lt;code&gt;helm install stable/nginx-ingress --namespace=kube-system --name=nginx-ingress&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/nginx.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that the nginx ingress controller also deploys a default backend - this will be served as a default backend (pretty clear name there).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now depending on where you manage your domain, you need to go and create the &lt;code&gt;A Record&lt;/code&gt; with a wildcard pointing back to the IP address of your ingress controller.&lt;/p&gt;

&lt;p&gt;In my case I manage my domain using CloudFlare, so the steps are pretty clear and straightforward:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/cloudflare.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We will also point &lt;code&gt;draft&lt;/code&gt; to write its config in &lt;code&gt;/cluster&lt;/code&gt;: &lt;code&gt;export DRAFT_HOME=/cluster&lt;/code&gt; and initialize &lt;code&gt;draft&lt;/code&gt;, specifying it to also configure the ingress controller:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;draft init --ingress-enabled&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will prompt you to enter your container registry credentials and the top level domain record you created.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that if you are using Docker Hub, the URL is: docker.io/username&lt;/p&gt;

&lt;p&gt;Note that you need to specify the top level domain (without the wildcard, see image below)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/draft-init.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now if we inspect our cluster we can see the &lt;code&gt;draftd&lt;/code&gt; server, &lt;code&gt;tiller&lt;/code&gt; and the ingress controller.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/inspect.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Azure/draft/blob/master/docs/ingress.md#i-dont-manage-a-domain&#34;&gt;If you don&amp;rsquo;t manage a domain, please see the instructions here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;creating-an-application&#34;&gt;Creating an application&lt;/h1&gt;

&lt;p&gt;Remember earlier that we also mounted a local directory where we will write our application. This was to allow us to easily use VS Code to develop the application.&lt;/p&gt;

&lt;p&gt;Now to the part where we actually create an application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can &lt;a href=&#34;https://github.com/Azure/draft/blob/master/docs/getting-started.md&#34;&gt;find a getting started guide at the GitHub repo for Draft&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Azure/draft/blob/master/docs/packs.md&#34;&gt;Draft already has packs&lt;/a&gt; that can autodetect your application and deploy it to your cluster for you.&lt;/p&gt;

&lt;p&gt;The packs are basically &lt;code&gt;helm&lt;/code&gt; chart templates for &lt;a href=&#34;https://github.com/Azure/draft/tree/master/packs&#34;&gt;various programming languages and frameworks&lt;/a&gt;, and you can easily write your own pack.&lt;/p&gt;

&lt;p&gt;This is the application we will use, a very simple Go web app:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/7de20b06733ffcc187153cdfa8abf087.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/simple-go.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We will create a new app using &lt;code&gt;draft&lt;/code&gt; by executing &lt;code&gt;draft create --app &amp;lt;name-for-app&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/draft-create.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This command will detect the application language (that 6 digit certainty&amp;hellip; :D) and create some new files for us: a Dockerfile, a &lt;code&gt;draft.toml&lt;/code&gt; file and a Helm chart.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/new-files.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Taking a look at &lt;code&gt;draft.toml&lt;/code&gt;, we can see that it will deploy a new app called &lt;code&gt;simple-go&lt;/code&gt; (that&amp;rsquo;s how I named it, if you omit the name you will get a randomly generated name) on the &lt;code&gt;default&lt;/code&gt; namespace.&lt;/p&gt;

&lt;p&gt;If you change the &lt;code&gt;watch&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt;, it will also look for changes on your local filesystem and redeploy the app on every change:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[environments]
  [environments.development]
    name = &amp;quot;simple-go&amp;quot;
    namespace = &amp;quot;default&amp;quot;
    wait = false
    watch = true
    watch_delay = 2

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing &lt;code&gt;draft up&lt;/code&gt; will automatically build the image and push it to the image repository.&lt;/p&gt;

&lt;p&gt;Note that all the work is done inside a pod in your cluster! There is no &lt;code&gt;docker build&lt;/code&gt; or &lt;code&gt;docker push&lt;/code&gt; step executed locally.&lt;/p&gt;

&lt;p&gt;Then there is the release step, which will install the Helm chart of your application on the cluster, also configuring the public endpoint of your application as: http:// draft-app-name.A-Record.yourdomain.com.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/build.png&#34; alt=&#34;&#34; /&gt;
&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/app.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In my case, the public endpoint of my application will be: &lt;a href=&#34;http://simple-go.draft.k8s.radu-matei.com&#34;&gt;http://simple-go.draft.k8s.radu-matei.com&lt;/a&gt; :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/public-app.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note that for any update of your application (that is you modifying the app locally and saving it) while the &lt;code&gt;draft up&lt;/code&gt; process is running, you will get the updated version of your application deployed automatically.&lt;/p&gt;

&lt;h1 id=&#34;investigating-what-actually-happens&#34;&gt;Investigating what actually happens&lt;/h1&gt;

&lt;p&gt;Remember that you also exposed port 8080 from the container? Now it&amp;rsquo;s time to start the proxy that will allow us to browse the Kubernetes dashboard locally:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl proxy --port 8080 --address 0.0.0.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, if you also exposed port 8080 on your host can access: &lt;a href=&#34;http://localhost:8080/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy/#!/node?namespace=_all&#34;&gt;http://localhost:8080/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy/#!/node?namespace=_all&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you go to all your pods, you will see a pod called &lt;code&gt;draftd-&amp;lt;some-random-id&amp;gt;&lt;/code&gt;:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/draftd-pod.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you go to its logs, you will see the image building and pushing process:
&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/draftd-logs.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Among other logs, you can see that it pushd the image to the container image repository we specified when initially setting up &lt;code&gt;draft&lt;/code&gt;, &lt;code&gt;draftaccount&lt;/code&gt;, with the name we specified for the app. Let&amp;rsquo;s see that:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s-helm-draft-azure/docker-hub.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now you can update the app locally (save the source code) and the app will be automatically updated on your cluster.
You don&amp;rsquo;t need to have Go (or whatever language you use for developement) locally, not even Docker. Using Draft you don&amp;rsquo;t need to understand how to write a Dockerfile, or a Helm chart - you simply want your app in the cluster.&lt;/p&gt;

&lt;h1 id=&#34;exiting-the-container&#34;&gt;Exiting the container&lt;/h1&gt;

&lt;p&gt;When you are done working, simply exit the container - no global config was written, no context switching is necessary to change between different clusters - you simply have a directory with all config for your cluster - &lt;code&gt;kubeconfig&lt;/code&gt; and config for &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;draft&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next time you need to work with this cluster, either start this same container, or start a new one with the same command as above and mount the folder with the config.&lt;/p&gt;

&lt;p&gt;Moreover, if you use multiple machines, you can keep the config folders in a file share (Azure Storage, Google Cloud Storage Bucket, S3) and start the container that has all the tools there. No more pasting SSH keys and cluster config files on Slack (guilty here&amp;hellip;)&lt;/p&gt;

&lt;p&gt;You can also use the same container with a different config folder for another cluster. That easy :)&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;We saw how to get started with Helm and Draft and tried a new approach at config management for multiple clusters using a config folder for each cluster.
We configured &lt;code&gt;helm&lt;/code&gt; and &lt;code&gt;draft&lt;/code&gt;, set up an ingress controller that used a domain we own, then deployed new apps to the cluster in seconds without writing Dockerfiles, Kubernetes deployment files or Helm charts.  We just worry about our app.&lt;/p&gt;

&lt;h1 id=&#34;feedback&#34;&gt;Feedback&lt;/h1&gt;

&lt;p&gt;If you have a better aproach at any of the concepts presented in this article, or have any questions, please use the comments below.
As always, thanks for reading, and any feedback is highly appreciated :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes 1.8 on Azure</title>
      <link>https://radu-matei.com/blog/k8s18-azure/</link>
      <pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s18-azure/</guid>
      <description>

&lt;h1 id=&#34;table-of-content&#34;&gt;Table of Content&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#introduction&#34;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploying-orchestrator-clusters-in-azure&#34;&gt;Deploying orchestrator clusters in Azure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getting-the-acs-engine-binary&#34;&gt;Getting the acs-engine binary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deploy-the-cluster&#34;&gt;Deploy the cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion-feedback&#34;&gt;Conclusion and feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h1&gt;

&lt;p&gt;This tutorial uses Azure to provision the infrastructure required to run a Kubernetes cluster. If you don&amp;rsquo;t have an Azure subscription you can &lt;a href=&#34;https://azure.microsoft.com/en-us/free/?v=17.39a&#34;&gt;create a free account and get $200 for 12 months&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This tutorial deploys 4 D2_V2 VMs (1 master + 3 agents) with Linux that will cost approximately $13 - $14 / day, but you can change the type of the VM to be D1_V2, and the cost will go down to $6 / day.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that the pricing will vary slightly based on the location where you deploy the VMs.&lt;/p&gt;

&lt;p&gt;Cost estimation created using the &lt;a href=&#34;https://azure.microsoft.com/en-us/pricing/calculator/&#34;&gt;Azure Pricing Calculator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/pricing.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;On September 28th, Kubernetes hit version 1.8 with improved support for Role Based Access Control (RBAC), TLS certificate rotation and other cool features. &lt;a href=&#34;http://blog.kubernetes.io/2017/09/kubernetes-18-security-workloads-and.html&#34;&gt;You can read the full blog post that announces the release here&lt;/a&gt; and you can see &lt;a href=&#34;https://github.com/kubernetes/kubernetes/releases/tag/v1.8.0&#34;&gt;the release on GitHub&lt;/a&gt; and the &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md#v180&#34;&gt;associated changelog with all new features&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this article we will explore how to deploy a Kubernetes cluster with version 1.8 on Azure.&lt;/p&gt;

&lt;p&gt;If you are familiar with deploying orchestrators in Azure, or you only want to see how to deploy Kubernetes 1.8, you can &lt;a href=&#34;#getting-the-acs-engine-binary&#34;&gt;skip the following section and go directly to where the action actually starts.&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-orchestrator-clusters-in-azure&#34;&gt;Deploying orchestrator clusters in Azure&lt;/h1&gt;

&lt;p&gt;There are a couple of ways to deploy an orchestrator cluster in Azure. First, there is Azure Container Service (that we used in the past to &lt;a href=&#34;https://radu-matei.com/blog/kubernetes-jenkins-azure/&#34;&gt;deploy a Kubernetes cluster&lt;/a&gt;). &lt;a href=&#34;https://azure.microsoft.com/en-us/services/container-service/&#34;&gt;Azure Container Service&lt;/a&gt; allows you to easily &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/container-service/&#34;&gt;deploy Kubernetes, Docker Swarm or DC/OS clusters from the Azure Portal or using the &lt;code&gt;az&lt;/code&gt; command line&lt;/a&gt;. This is the way to go if you don&amp;rsquo;t want to customize your cluster and you are ok with the default values that Azure provides for you.&lt;/p&gt;

&lt;p&gt;Then there is a tool called &lt;a href=&#34;https://github.com/azure/acs-engine&#34;&gt;&lt;code&gt;acs-engine&lt;/code&gt;&lt;/a&gt;. This is basically the &amp;ldquo;engine&amp;rdquo; that Azure Container Service uses to deploy your clusters, and we will use it to deploy a custom version of our Kubernetes cluster, in this case the new 1.8 version.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;acs-engine&lt;/code&gt; takes a &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/master/docs/clusterdefinition.md&#34;&gt;cluster definition file&lt;/a&gt; where you can specify options for your cluster (like orchestrator to use - Kubernetes, Docker Swarm Mode, DC/OS and their specific versions, networking policies, master and agent profiles and others) and generates &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates&#34;&gt;ARM (Azure Resource Manager) templates&lt;/a&gt; that Azure uses to deploy all resources for your cluster (VMs for masters and agents with your orchestrator configured, load balancers, networking, storage adn other resources).&lt;/p&gt;

&lt;p&gt;Kubernetes 1.8 has just been released, and together with it came &lt;a href=&#34;https://github.com/Azure/acs-engine/releases&#34;&gt;v0.8.0 of &lt;code&gt;acs-engine&lt;/code&gt;&lt;/a&gt; with support for Kubernetes 1.8.&lt;/p&gt;

&lt;p&gt;You can follow this article on your local machine, inside a Docker container or using the Azure Cloud Shell, and all of these versions being very similar (basically you only change the OS version of the acs-engine binary).&lt;/p&gt;

&lt;h1 id=&#34;getting-the-acs-engine-binary&#34;&gt;Getting the acs-engine binary&lt;/h1&gt;

&lt;p&gt;In this step all you need to do is download the the binary associated with v0.8.0 of &lt;code&gt;acs-engine&lt;/code&gt; for your operating system. I will use the Azure Cloud Shell (which is Linux), but you can do the same thing for macOS (by getting the Darwin specific binaries) or for Windows.&lt;/p&gt;

&lt;p&gt;First you need to download the GitHub release archive for Linux:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget https://github.com/Azure/acs-engine/releases/download/v0.8.0/acs-engine-v0.8.0-linux-amd64.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then, you need to unarchive it:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tar -xvzf acs-engine-v0.8.0-linux-amd64.tar.gz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This will create a folder called &lt;code&gt;acs-engine-v0.8.0-linux-amd64&lt;/code&gt;, and inside it you will find (among the license and the readme) the &lt;code&gt;acs-engine&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/acs-engine-shell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now you only need to put it in your path (or move it to a directory that is in your path) and you have the &lt;code&gt;acs-engine&lt;/code&gt; binary accessible from anywhere.&lt;/p&gt;

&lt;p&gt;We will now use this binary inside the Azure Cloud Shell to deploy a Kubernetes 1.8 cluster to Azure, using a cluster definition template file.&lt;/p&gt;

&lt;h1 id=&#34;deploy-the-cluster&#34;&gt;Deploy the cluster&lt;/h1&gt;

&lt;p&gt;This is how a typical cluster definition file looks for Kubernetes. Compared to &lt;a href=&#34;https://github.com/Azure/acs-engine/blob/master/examples/kubernetes.json&#34;&gt;the example offered in the repo&lt;/a&gt;, this only adds the &lt;code&gt;orchestratorRelease&lt;/code&gt; property and sets it to &lt;code&gt;1.8&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/radu-matei/7ba751e0074621313b997c12ccf28dbe.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The great thing about this version of &lt;code&gt;acs-engine&lt;/code&gt; is that you will only need one command to deploy this, and you pass a few parameters (in older versions you would generate ARM templates using &lt;code&gt;acs-engine&lt;/code&gt; and deploy them with the &lt;code&gt;az&lt;/code&gt; command line):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;an Azure subscription id (you can find it using &lt;code&gt;az account show&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;a DNS prefix for your cluster&lt;/li&gt;
&lt;li&gt;the location of your cluster&lt;/li&gt;
&lt;li&gt;the cluster definition file from above&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;acs-engine deploy --subscription-id &amp;lt;your-subscription-id&amp;gt; \
    --dns-prefix &amp;lt;your-dns-prefix&amp;gt; --location westeurope \
    --auto-suffix --api-model kubernetes18.json
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note the &lt;code&gt;orchestratorRelease&lt;/code&gt; property in the JSON file set to &lt;code&gt;1.8&lt;/code&gt;!
Note that it automatically creates all assets for you including a service principal and a resource group.&lt;/p&gt;

&lt;p&gt;Since you are in the Azure Cloud Shell, you are already authenticated into your Azure account. If you run elswhere, the will be another step involved where you login to &lt;code&gt;aka.ms/devicelogin&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/shell.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the deployment succeeds, you should see a resource group in your subscription with all your Kubernetes assets:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/resource-group.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The output of the command above is an &lt;code&gt;_output&lt;/code&gt; folder where you have your SSH keys and the &lt;code&gt;kubeconfig&lt;/code&gt; to access the cluster.&lt;/p&gt;

&lt;p&gt;Now to access the cluster.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Depending on which version of &lt;code&gt;kubectl&lt;/code&gt; you have installed, you might want to &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-via-curl&#34;&gt;upgrade to 1.8 as it is detailed here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you need to point your &lt;code&gt;kubectl&lt;/code&gt; to the &lt;code&gt;kubeconfig&lt;/code&gt; file location. This has to correspond to the Azure location where you deployed your cluster - in my case West Europe:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;export KUBECONFIG=_output/kubernetes1dot8-59d7ee12/kubeconfig/kubeconfig.westeurope.json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;At this point you can use &lt;code&gt;kubectl&lt;/code&gt; to get information about your cluster and your nodes:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl get nodes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://radu-matei.com/img/article-photos/k8s18-azure/k8s18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note the &lt;code&gt;v1.8.0&lt;/code&gt;!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you have a Kubernetes 1.8 cluster where you can go ahead and use all the awesome features!&lt;/p&gt;

&lt;h1 id=&#34;configure-kubectl-from-outisde-the-azure-cloud-shell&#34;&gt;Configure &lt;code&gt;kubectl&lt;/code&gt; from outisde the Azure Cloud Shell&lt;/h1&gt;

&lt;p&gt;Since we deployed the cluster using the Azure Cloud Shell, all certificates and SSH keys are found in the &lt;code&gt;_output&lt;/code&gt; directory from where you executed the &lt;code&gt;acs-engine deploy&lt;/code&gt; command.
You will want to have access to your cluster from outside the browser (for obvious reasons), so you will have to download the certificates and keys.&lt;/p&gt;

&lt;p&gt;After watching &lt;a href=&#34;https://channel9.msdn.com/Shows/Azure-Friday/Azure-Cloud-Shell&#34;&gt;this video on Channel9 explaining Azure Cloud Shell&lt;/a&gt;, you simply need to put your files in &lt;code&gt;/home/&amp;lt;your-username&amp;gt;/clouddrive&lt;/code&gt;. Then you will find them in the Azure Storage account (more specifically in the the File Share) associated with your Cloud Shell.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you don&amp;rsquo;t want to manually download each file (and you don&amp;rsquo;t have to mount the share), simply make an archive of the entire folder download it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then, point your local &lt;code&gt;kubectl&lt;/code&gt; to the &lt;code&gt;kubeconfig.&amp;lt;azure-location&amp;gt;.json&lt;/code&gt; file and you have access to your cluster.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note that you can also create new users for your cluster, assign them roles and just download the key and certificate for the user, &lt;a href=&#34;https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/&#34;&gt;as described in the Bitnami documentation&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion-feedback&#34;&gt;Conclusion, feedback&lt;/h1&gt;

&lt;p&gt;In this brief article we saw how to deploy a Kubernetes 1.8 cluster on Azure using &lt;code&gt;acs-engine&lt;/code&gt; and the Azure Cloud Shell.&lt;/p&gt;

&lt;p&gt;If you have any ideas, comments or feedback, please use the comments below :)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>