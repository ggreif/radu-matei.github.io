<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Azure on Radu Matei&#39;s Blog</title>
    <link>https://radu-matei.com/categories/azure/</link>
    <description>Recent content in Azure on Radu Matei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Dec 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://radu-matei.com/categories/azure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Adding native Go in Azure Functions</title>
      <link>https://radu-matei.com/blog/golang-azure-functions/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/golang-azure-functions/</guid>
      <description>Table of Contents  Introduction  Introduction Fall 2017 came with the announcement of Azure Functions on Linux and Mac and the ability to add the Azure Functions runtime in a container.
Besides that, the runtime has been split between a host (which manages function events) and language worker processes (which runs user functions for a given language). These two pieces communicate using gRPC as a messaging layer. - essentially, this allows you to add support for Azure Functions to any language you want - you only have to create a gRPC implementation in your language of choice and accept incoming requests from the runtime host.</description>
    </item>
    
    <item>
      <title>Update Azure Container Instances with Docker Hub webhooks</title>
      <link>https://radu-matei.com/blog/aci-update/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aci-update/</guid>
      <description>Table of Contents  Introduction Webhooks from Docker Hub Using the Azure Go SDK to update container groups See it in action Final Thoughts Feedback  Introduction Back in July, Microsoft announced Azure Container Instances, a new Azure service delivering containers with great simplicity and speed and without any Virtual Machine infrastructure to manage. ACIs are the fastest and easiest way to run a container in the cloud.
Essentially, this allowed you to run single or multi-container groups (scheduled on the same host machine, within the same local network, storage and lifetime) with fast startup times, hypervisor-level security, public IP address connectivity and billing by the second.</description>
    </item>
    
    <item>
      <title>Best of Both worlds: Azure App Service and Kubernetes</title>
      <link>https://radu-matei.com/blog/k8s-appsvc/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s-appsvc/</guid>
      <description>Table of Contents  Introduction Prerequisites Why not just expose services publicly? Deploy Kubernetes services with a private IP The networking settings Testing the integration Conclusion Next Steps Feedback  Introduction In this article we will explore how to integrate Azure App Service and Kubernetes within the same Azure Virtual Network and consume Kubernetes services from an Azure App Service app without exposing them on the public Internet.
There will be lots of situations when we want to use both the simplicity and features of a PaaS service (such as autoscaling, easy SSL, or any other cool feature) for a component and the flexibility of Kubernetes for others - in this article we will see how to achieve this without exposing services on the Internet.</description>
    </item>
    
    <item>
      <title>Get started with Helm and Draft for Kubernetes</title>
      <link>https://radu-matei.com/blog/k8s-helm-draft-azure/</link>
      <pubDate>Sat, 07 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s-helm-draft-azure/</guid>
      <description>Table of contents  Introduction Using kubectl, helm and draft Configure Helm Configure Draft Creating an application Investigating what actually happens Exiting the container Conclusion Feedback  Prerequisites In the previous tutorial I used Azure to provision the infrastructure required to run a Kubernetes cluster. If you don&amp;rsquo;t have an Azure subscription you can create a free account and get $200 for 12 months.
I deployed 4 D2_V2 VMs (1 master + 3 agents) with Linux and will cost approximately $13 - $14 / day, but you can change the type of the VM to be D1_V2 in the cluster definition, and the cost will go down to $6 / day.</description>
    </item>
    
    <item>
      <title>Kubernetes 1.8 on Azure</title>
      <link>https://radu-matei.com/blog/k8s18-azure/</link>
      <pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s18-azure/</guid>
      <description>Table of Content  Introduction Deploying orchestrator clusters in Azure Getting the acs-engine binary Deploy the cluster Conclusion and feedback  Prerequisites This tutorial uses Azure to provision the infrastructure required to run a Kubernetes cluster. If you don&amp;rsquo;t have an Azure subscription you can create a free account and get $200 for 12 months.
This tutorial deploys 4 D2_V2 VMs (1 master + 3 agents) with Linux that will cost approximately $13 - $14 / day, but you can change the type of the VM to be D1_V2, and the cost will go down to $6 / day.</description>
    </item>
    
    <item>
      <title>The Hybrid Cluster: A CI/CD Story [Part 1] - Configuring a hybrid swarm mode cluster in Azure with acs-engine</title>
      <link>https://radu-matei.com/blog/hybrid-swarmmode/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/hybrid-swarmmode/</guid>
      <description>Introduction Now, you can create yourself a hybrid cluster within any private network where you have a Windows Server 2016 with Containers and a Linux machine - it can be locally, with VirtualBox, Hyper-V or VMWare, or it can be on your cloud provider of choice. The simplicity of Docker Swarm allows us to easily create a swarm within minutes of having our VMs deployed.
Here is a list of resources you might want to get started with before diving into this article:</description>
    </item>
    
    <item>
      <title>Dockerizing an ASP.NET Core application with GitHub, Docker Cloud and Azure</title>
      <link>https://radu-matei.com/blog/aspnet-core-docker-azure/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-docker-azure/</guid>
      <description>Introduction In this article, we will take the simplest ASP.NET Core application, run it with Docker locally, then create Continuous Integration and Continuous Deployment flows using a GitHub repository, Docker Cloud and an Azure virtual machine that will act as a node for Docker Cloud.
If you don&amp;rsquo;t want to create an ASP.NET Core application but are interested in the CI/CD workflow, or if you already have a GitHub repository with a complete application with a Dockerfile, you might want to skip to the part we start creating the CI/CD workflow.</description>
    </item>
    
    <item>
      <title>ASP.NET Core MVC and SignalR Core</title>
      <link>https://radu-matei.com/blog/aspnet-core-mvc-signalr/</link>
      <pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-mvc-signalr/</guid>
      <description>NOTICE This article is based on an old version of SignalR and is no longer functional / maintained - it is kept here only for historical purposes, you should visit this article that is current as of November / December 2017! All functionality of this article and much more can be found in the new article! 
Introduction In this article we will take a look at how to integrate ASP.</description>
    </item>
    
  </channel>
</rss>