<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Radu Matei&#39;s Blog</title>
    <link>https://radu-matei.com/blog/</link>
    <description>Recent content in Blogs on Radu Matei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 20 Aug 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://radu-matei.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Filter secrets from Kubernetes logs</title>
      <link>https://radu-matei.com/blog/filter-k8s-logs/</link>
      <pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/filter-k8s-logs/</guid>
      <description>Introduction How to filter the logs of a Kubernetes pod The filtering process The sample application Conclusion  Introduction Running any non-trivial application on Kubernetes will most likely require authorized access to other components - databases, storage buckets, APIs - all of which require a connection string or some sort of access key. Storing these values in Kubernetes is done through Secrets, and while there are plenty of ways to make sure the secrets are safe while at rest, as well as how to configure an external KMS provider, once the secret is injected into your application container, its value will be plain text.</description>
    </item>
    
    <item>
      <title>The state of debugging microservices on Kubernetes</title>
      <link>https://radu-matei.com/blog/state-of-debugging-microservices-on-k8s/</link>
      <pubDate>Sat, 05 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/state-of-debugging-microservices-on-k8s/</guid>
      <description>Credit for the image goes to Ashley McNamara&amp;rsquo;s awesome Gopher collection
 Where are we? How did we get here? For as long as we have been writing software, we have also introduced bugs in our applications. Back when we were developing monoliths, we could simply start the IDE of choice, add a couple of breakpoints, step through the code and hopefully solve the issue. There was a single place where the application was running, where logs were visible and where the application could be diagnosed.</description>
    </item>
    
    <item>
      <title>Debug Helm and Tiller using VS Code and Draft</title>
      <link>https://radu-matei.com/blog/debug-helm-tiller/</link>
      <pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/debug-helm-tiller/</guid>
      <description>Introduction Debugging the Helm CLI Debugging Tiller  Building the Tiller binary for debugging Creating the Docker image, pushing it to a registry The Helm template for our deployment Putting it all together. Start debugging with VS Code  Conclusion  Introduction In today&amp;rsquo;s article we will explore how to take a real-world application and start developing, debugging and deploying it to a Kubernetes cluster and how to use a couple of open-source tools to make our lives easier in the process.</description>
    </item>
    
    <item>
      <title>Using Draft to develop front-end &#43; back-end applications. Experimenting with Draft, VS Code and remote debugging.</title>
      <link>https://radu-matei.com/blog/real-world-draft/</link>
      <pubDate>Tue, 10 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/real-world-draft/</guid>
      <description>+ [Introduction](#introduction)   Prerequisites Develop, deploy and debug front-end + back-end apps on Kubernetes  Deploy the Node back-end Exploring the Angular front-end Updating the back-end Experimenting with VS Code and remote debugging  Conclusion  Introduction  Application containers have skyrocketed in popularity over the last few years. In recent months, Kubernetes has emerged as a popular solution for orchestrating these containers. While many turn to Kubernetes for its extensible architecture and vibrant open-source community, some still view Kubernetes as too difficult to use.</description>
    </item>
    
    <item>
      <title>kube-toolkit: Toolkit for creating gRPC-based CLI tools for Kubernetes, written in Go</title>
      <link>https://radu-matei.com/blog/kube-toolkit/</link>
      <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/kube-toolkit/</guid>
      <description>Table of Contents  Introduction Architecture Vendoring kube-toolkit Defining and using gRPC services Connecting to the Kubernetes cluster Using cobra, folder structure and adding your own commands See in in action Conclusion  Introduction If you ever used Helm or Draft, you know they are very cool command-line tools that connect to a Kubernetes cluster, more specifically to a server-side component (Tiller in the case of Helm, Draftd for Draft) without exposing ports on the Internet, and allow you to interact with your cluster through gRPC-based services.</description>
    </item>
    
    <item>
      <title>Update Azure Container Instances with Docker Hub webhooks</title>
      <link>https://radu-matei.com/blog/aci-update/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aci-update/</guid>
      <description>Table of Contents  Introduction Webhooks from Docker Hub Using the Azure Go SDK to update container groups See it in action Final Thoughts Feedback  Introduction Back in July, Microsoft announced Azure Container Instances, a new Azure service delivering containers with great simplicity and speed and without any Virtual Machine infrastructure to manage. ACIs are the fastest and easiest way to run a container in the cloud.
Essentially, this allowed you to run single or multi-container groups (scheduled on the same host machine, within the same local network, storage and lifetime) with fast startup times, hypervisor-level security, public IP address connectivity and billing by the second.</description>
    </item>
    
    <item>
      <title>Getting started with SignalR Alpha 2</title>
      <link>https://radu-matei.com/blog/signalr-core/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/signalr-core/</guid>
      <description>Table of Contents  Introduction Chat, of course Adding a C# console client Handling connection and disconnection events Working with an MVC/WebApi application Streaming Sending binary data Redis scaleout Conclusion  Introduction  ASP.NET SignalR is a library for ASP.NET developers that simplifies the process of adding real-time web functionality to applications. Real-time web functionality is the ability to have server code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.</description>
    </item>
    
    <item>
      <title>Best of Both worlds: Azure App Service and Kubernetes</title>
      <link>https://radu-matei.com/blog/k8s-appsvc/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s-appsvc/</guid>
      <description>Table of Contents  Introduction Prerequisites Why not just expose services publicly? Deploy Kubernetes services with a private IP The networking settings Testing the integration Conclusion Next Steps Feedback  Introduction In this article we will explore how to integrate Azure App Service and Kubernetes within the same Azure Virtual Network and consume Kubernetes services from an Azure App Service app without exposing them on the public Internet.
There will be lots of situations when we want to use both the simplicity and features of a PaaS service (such as autoscaling, easy SSL, or any other cool feature) for a component and the flexibility of Kubernetes for others - in this article we will see how to achieve this without exposing services on the Internet.</description>
    </item>
    
    <item>
      <title>Jenkins pipelines with Kubernetes </title>
      <link>https://radu-matei.com/blog/kubernetes-jenkins-azure/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/kubernetes-jenkins-azure/</guid>
      <description>Table of Contents  Introduction Prerequisites Deploying Jenkins with Helm Create credentials for your image repository The Jenkinsfile Using the Jenkinsfile Investigating what actually happens in the cluster Conclusion Feedback  Introduction In previous articles we deployed a Kubernetes 1.8 cluster to Azure using acs-engine, then configured Helm and Draft to simplify testing applications.
In this article we will explore how to deploy Jenkins using Helm and how to configure Jenkins pipelines that build containers, push images to an image repository and update Kubernetes deployments.</description>
    </item>
    
    <item>
      <title>Get started with Helm and Draft for Kubernetes</title>
      <link>https://radu-matei.com/blog/k8s-helm-draft-azure/</link>
      <pubDate>Sat, 07 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s-helm-draft-azure/</guid>
      <description>Table of contents  Introduction Using kubectl, helm and draft Configure Helm Configure Draft Creating an application Investigating what actually happens Exiting the container Conclusion Feedback  Prerequisites In the previous tutorial I used Azure to provision the infrastructure required to run a Kubernetes cluster. If you don&amp;rsquo;t have an Azure subscription you can create a free account and get $200 for 12 months.
I deployed 4 D2_V2 VMs (1 master + 3 agents) with Linux and will cost approximately $13 - $14 / day, but you can change the type of the VM to be D1_V2 in the cluster definition, and the cost will go down to $6 / day.</description>
    </item>
    
    <item>
      <title>Kubernetes 1.8 on Azure</title>
      <link>https://radu-matei.com/blog/k8s18-azure/</link>
      <pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/k8s18-azure/</guid>
      <description>Table of Content  Introduction Deploying orchestrator clusters in Azure Getting the acs-engine binary Deploy the cluster Conclusion and feedback  Prerequisites This tutorial uses Azure to provision the infrastructure required to run a Kubernetes cluster. If you don&amp;rsquo;t have an Azure subscription you can create a free account and get $200 for 12 months.
This tutorial deploys 4 D2_V2 VMs (1 master + 3 agents) with Linux that will cost approximately $13 - $14 / day, but you can change the type of the VM to be D1_V2, and the cost will go down to $6 / day.</description>
    </item>
    
    <item>
      <title>The Hybrid Cluster: A CI/CD Story [Part 1] - Configuring a hybrid swarm mode cluster in Azure with acs-engine</title>
      <link>https://radu-matei.com/blog/hybrid-swarmmode/</link>
      <pubDate>Mon, 03 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/hybrid-swarmmode/</guid>
      <description>Introduction Now, you can create yourself a hybrid cluster within any private network where you have a Windows Server 2016 with Containers and a Linux machine - it can be locally, with VirtualBox, Hyper-V or VMWare, or it can be on your cloud provider of choice. The simplicity of Docker Swarm allows us to easily create a swarm within minutes of having our VMs deployed.
Here is a list of resources you might want to get started with before diving into this article:</description>
    </item>
    
    <item>
      <title>Real-Time ASP .NET Core</title>
      <link>https://radu-matei.com/blog/real-time-aspnet-core/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/real-time-aspnet-core/</guid>
      <description>NOTICE If you&amp;rsquo;re looking for SignalR, here you can find a blog post containing most common scenarios with the latest version of SignalR, alpha2 - streaming, binary protocols, Redis backplane and more 
What is this? This is an ASP .NET Core middleware for providing real-time functionality to your applications. To its core, this is a WebSockets middleware for ASP .NET Core applications with TypeScript / JavaScript and .NET clients.</description>
    </item>
    
    <item>
      <title>Creating a WebSockets middleware for ASP .NET Core</title>
      <link>https://radu-matei.com/blog/aspnet-core-websockets-middleware/</link>
      <pubDate>Fri, 30 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-websockets-middleware/</guid>
      <description>UPDATE - February 2017 This article describes the latest development of websocket-manager and how to use it in your application.
While the general aspects provided in this article about creating a websockets middleware for Asp .Net Core are still valid, the specific information about the websocket-manager project have changed, since I updated a lot of parts.
The version of the project described in this article can still be found in the blog-article branch on GitHub.</description>
    </item>
    
    <item>
      <title>Dockerizing an ASP.NET Core application with GitHub, Docker Cloud and Azure</title>
      <link>https://radu-matei.com/blog/aspnet-core-docker-azure/</link>
      <pubDate>Sat, 26 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-docker-azure/</guid>
      <description>Introduction In this article, we will take the simplest ASP.NET Core application, run it with Docker locally, then create Continuous Integration and Continuous Deployment flows using a GitHub repository, Docker Cloud and an Azure virtual machine that will act as a node for Docker Cloud.
If you don&amp;rsquo;t want to create an ASP.NET Core application but are interested in the CI/CD workflow, or if you already have a GitHub repository with a complete application with a Dockerfile, you might want to skip to the part we start creating the CI/CD workflow.</description>
    </item>
    
    <item>
      <title>Get started with Raspberry Pi3, Sense HAT and Azure IoT Suite</title>
      <link>https://radu-matei.com/blog/rpi-sensehat-telemetry/</link>
      <pubDate>Mon, 10 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/rpi-sensehat-telemetry/</guid>
      <description>You can check the GitHub repository of this project for the full source code
 Introduction In this blog post, we will get started with the Raspberry Pi3, the Sense HAT and Azure IoT Suite. More specifically, from the IoT Suite we will use IoT Hub, and Stream Analytics, which we will detail a little later.
The end goal of this little project is to acquire data from the sensors, upload the data to IoT Hub, which feeds it into Stream Analytics, with outputs to an Azure SQL database (for storage) and to Service Bus (for consuming the data in real-time from various applications).</description>
    </item>
    
    <item>
      <title>ASP.NET Core MVC and SignalR Core</title>
      <link>https://radu-matei.com/blog/aspnet-core-mvc-signalr/</link>
      <pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-mvc-signalr/</guid>
      <description>NOTICE This article is based on an old version of SignalR and is no longer functional / maintained - it is kept here only for historical purposes, you should visit this article that is current as of November / December 2017! All functionality of this article and much more can be found in the new article! 
Introduction In this article we will take a look at how to integrate ASP.</description>
    </item>
    
    <item>
      <title>Inject ASP.NET Core Dependencies from JSON files</title>
      <link>https://radu-matei.com/blog/aspnet-core-json-dependency-injection/</link>
      <pubDate>Thu, 18 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-json-dependency-injection/</guid>
      <description>Table of Content  Introduction The need for registering services through a JSON file Adding the required packages Creating a dummy service How to inject an ITest service The JSON file The Service class Adding the services Testing the application The Startup class Conclusion  Introduction &amp;ldquo;Back in the days&amp;rdquo; of ASP.NET 4.x, each of the framework components (MVC, WebAPI, OWIN, SignalR) had its own dependency resolver and its own way of integrating with the framework.</description>
    </item>
    
    <item>
      <title>Introduction to ASP .NET Core MVC API</title>
      <link>https://radu-matei.com/blog/aspnet-core-api/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-api/</guid>
      <description>Table of Content  Introduction Adding the MVC services to our application Adding the Post class Creating an IPostRepository interface Creating an in-memory implementation of IPostRepository The PostController class Registering the repository service in Startup Startup.cs Testing the application Conclusion  Introduction Up to this point, we have been learning about .NET Core and VS Code, about ASP .NET Core, the Startup class, Routing and how to use JSON Configuration.</description>
    </item>
    
    <item>
      <title>ASP .NET Core JSON Configuration and Dependency Injection</title>
      <link>https://radu-matei.com/blog/aspnet-core-configuration-greeting/</link>
      <pubDate>Sat, 23 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-configuration-greeting/</guid>
      <description>Table of Content  Introduction Using the ASP .NET Core JSON Configuration Provider Building the configurable Greeting service Making use of ASP .NET Core Dependency Injection Conclusion  Introduction In the previous versions of ASP .NET, any configuration setting or parameter you needed was added in web.config (complete description of the old web.config file), or added in a separate XML file and referenced in web.config (for scenarios like database connection strings, or storing APIs access tokens).</description>
    </item>
    
    <item>
      <title>ASP .NET Core Routing</title>
      <link>https://radu-matei.com/blog/aspnet-core-routing/</link>
      <pubDate>Wed, 20 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-routing/</guid>
      <description>Table of Contents
 Routing  Introduction Installing the Routing package Adding the Routing Service in Startup Adding and handling custom routes The full Startup class Conclusion   Routing Introduction In the previous example we built a very simple web application that responded with Hello, Universe and the current server time for every request.
 When the application is running and you navigate to http://localhost5000, regardless of the path followed (http://localhost:5000/something/something-else/etc), the response is the same.</description>
    </item>
    
    <item>
      <title>ASP .NET Core Startup</title>
      <link>https://radu-matei.com/blog/aspnet-core-startup/</link>
      <pubDate>Tue, 19 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-startup/</guid>
      <description>The Startup class Introduction In the previous article we built a very basic web application that for every request had a very basic response - Hello, Universe with the server current time and date.
Any non-trivial application is going to need a mechanism to handle different types of requests and map them to specific services and middleware and configure services. This is accomplished through the Startup class, which is also the entry point for any incoming HTTP request.</description>
    </item>
    
    <item>
      <title>ASP .NET Core Introduction</title>
      <link>https://radu-matei.com/blog/aspnet-core-getting-started/</link>
      <pubDate>Mon, 18 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/aspnet-core-getting-started/</guid>
      <description>Table of Contents
 Introduction Getting Started with ASP .NET Core 1.0 Make the project a web application Conclusion  Introduction  ASP.NET Core is a new open-source and cross-platform framework for building modern cloud based internet connected applications, such as web apps, IoT apps and mobile backends.
ASP.NET Core apps can run on .NET Core or on the full .NET Framework. It was architected to provide an optimized development framework for apps that are deployed to the cloud or run on-premises.</description>
    </item>
    
    <item>
      <title>Getting Started with .NET Core and VS Code</title>
      <link>https://radu-matei.com/blog/dot-net-core-getting-started/</link>
      <pubDate>Sun, 17 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/dot-net-core-getting-started/</guid>
      <description>Table of Contents
 Getting started with .NET Core  Installing .NET Core Building a .NET Core application using the command line interface Installing Visual Studio Code Running in Visual Studio Code Debugging in Visual Studio Code Adding classes and navigating through code Conclusion   Getting started with .NET Core In the previous article, we saw what is .NET Core and what can we build with it. In this article, we will install .</description>
    </item>
    
    <item>
      <title>Introduction to .NET Core</title>
      <link>https://radu-matei.com/blog/dot-net-core-introduction/</link>
      <pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://radu-matei.com/blog/dot-net-core-introduction/</guid>
      <description>Table of Contents
 What is .NET Core? Scenarios for .NET Core .NET Standard - One library to rule them all Tools Conclusion  What is .NET Core?  .NET Core is a general purpose development platform maintained by Microsoft and the .NET community on GitHub. It is cross-platform, supporting Windows, macOS and Linux, and can be used in device, cloud, and embedded/IoT scenarios.
The following characteristics best define .</description>
    </item>
    
  </channel>
</rss>